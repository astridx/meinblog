---
date: 2021-11-07
title: 'Gatsby Blog mit maplibre GL JS unter Verwendung von React Hooks'
template: post
thumbnail: '../../thumbnails/maplibre.png'
slug: en/maplibre-blog-with-gatsby
langKey: de
categories:
  - MaplibreGL
tags:
  - MaplibreGL
  - geografische Daten
  - Geoinformationssystem
  - JavaScript-Bibliothek
  - Vektor-Tiles
  - Karten
  - Gatsby
---


I like to design websites with [Gatsby](https://www.gatsbyjs.com/) and have recently started using [MapLibre GL](https://maplibre.org/). I wish to combine the two. The idea is to create a travel blog where the map illustrates the text content by dynamically zooming into the relevant area. Ideally, the places from a blog post are marked with a marker. When navigating between different posts, the digital map continuously highlights the new regions instead of refreshing the entire map each time. This makes it easier for the reader to see the spatial context. While working on this project, I have stumbled over hurdles. I will highlight the learnings I have gained so far.

## Setup

In the following example code, I do not discuss every single line of code. Instead, I make the result available online in my [Github Repo](https://github.com/astridx/gatsby-maplibre-blog-tutorial). The branch `main` is created for MapLibre GL in version 1.x. The branch `test_maplibre_v2` contains additions for MapLibre GL 2.x. I assume you are familiar with Gatsby and React and have installed the basic dependencies.

> First steps with [React](https://de.reactjs.org/docs/getting-started.html) or [Gatsby](https://www.gatsbyjs.com/docs/tutorial/)

First, we create an empty Gatsby project. I use the [start project](https://www.gatsbyjs.com/docs/starters/) provided by Gatsby. This way the basics are pre-configured. The end result of this tutorial is a boilerplate structure. Feel free to adapt it to your individual needs afterwards.

```
$ gatsby new gatsby-maplibre-blog
```

After you have created the project, change to the project directory via `cd gatsby-maplibre-blog` and call `gatsby develop`. As a result, you will see the following output under the URL `http://localhost:8000/` in the browser:

![A screenshot of the Gatsby standard starter](images/bloggatsby1.png)

To tidy things up a bit, I changed the files `components/layout.js`, `pages/404.js` and `pages/index.js` in the `src` folder. 

> If you are familiar with Gatsby, you can also delete other contents of the boilerplate. To keep this example simple, it is enough to change the files `components/layout.js`, `pages/404.js` and `pages/index.js`.

```js
// index.js
import React from "react"
import Layout from "../components/layout"

const IndexPage = () => (
  <Layout>
    <h1>Reise Blog</h1>
  </Layout>
)

export default IndexPage
```

```js
// layout.js
import React from "react"
import PropTypes from "prop-types"

const Layout = ({ children }) => {
  return (
      <div>
        <main>{children}</main>
      </div>
  )
}

Layout.propTypes = {
  children: PropTypes.node.isRequired,
}

export default Layout
```

```js
// 404.js
import React from "react"

const NotFoundPage = () => (
  <>
    <h1>Page Not Found</h1>
  </>
)

export default NotFoundPage
```

I also cleaned up the file "gatsby-config.js". Here, too, I wanted to start with a minimum. So I removed a lot and changed the source path of the file to `content`. I also make sure that the folder named `content` exists in the root directory of my project. Since it does not yet exist in the project, I create it. We don't need it at the moment, but I will create Markdown files for blog posts in it later.dsafsa

```js
// gatsby-config.js
module.exports = {
  siteMetadata: {
    title: `Gatsby maplibre Blog`,
    description: ``,
    author: `Me`,
  },
  plugins: [
    `gatsby-plugin-react-helmet`,
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `content`,
        path: `${__dirname}/content`,
      },
    },
    `gatsby-transformer-sharp`,
    `gatsby-plugin-sharp`,
  ],
}
```

At this point, restart the development server to make sure there is no error. Run `gatsby develop` again. If you see no error messages, everything is fine.

![A screenshot of Gatsby default starter after tidy up](images/bloggatsby2.png)

## Install maplibre


We will install maplibre GL JS from NPM. There are a few maplibre wrapper projects, that give you many React components to use, and I have tried one but I felt a bit difficult to customize (due to my lack of understanding, not the fault of the library), and maplibre has a lot of official code examples based on vanilla JS so I thought I would give some time to learn to combine vanilla JS and React components myself. Nebenbei bleibe ich unabhängig.

You can follow [their guide](https://www.npmjs.com/package/maplibre-gl) but basically, you only need to run this command in the terminal:

```
$ npm i maplibre-gl
```

*Note: The current verion of `maplibre-gl` is `2.0.0-pre.6` at the time of writing.*

It also needs a stylesheet to display the map properly. You can include this CSS in the `<head>` of any HTML page using a map, but I will later add it in my component by directly importing from the npm module. It's up to you.

```
<link href='https://unpkg.com/maplibre-gl@1.15.2/dist/maplibre-gl.css' rel='stylesheet' />
```
> https://github.com/maplibre/maplibre-gl-js/blob/main/docs/README-unpkg.md

## Display The Map


I want the same map to be shared across multiple blog posts, so instead of adding a map on every page, I will instead add it the the `Layout` component, because every page that I will be creating will be wrapped with the component. And to keep the code clean and reusable, I will make a separate component called `Map`. Let's create `components/map.js`.

```
// map.js
import React, { useRef, useEffect, useState } from "react"
import maplibregl from "maplibre-gl"
import "maplibre-gl/dist/maplibre-gl.css"

const mapContainerStyle = {
  width: "100%",
  height: "120px",
}

const Map = () => {
  const mapContainerRef = useRef(null)

  const [map, setMap] = useState(null)

  useEffect(() => {
    const map = new maplibregl.Map({
      container: mapContainerRef.current,
      style: 'https://demotiles.maplibre.org/style.json',
      center: [-0.687787, 38.185674462487874],
      zoom: 10,
    })
    map.addControl(new maplibregl.NavigationControl(), "top-right")

    setMap(map)

    return () => map.remove()
  }, [])

  return <div ref={mapContainerRef} style={mapContainerStyle} />
}

export default Map
```

> https://maplibre.org/maplibre-gl-js-docs/example/simple-map/  Demotiles and keys

And include a Map component in `layout.js`

```
// layout.js
import React from "react"
import PropTypes from "prop-types"
import Map from "./map"

const Layout = ({ children }) => {
  return (
    <>
      <Map />
      <main>{children}</main>
    </>
  )
}

Layout.propTypes = {
  children: PropTypes.node.isRequired,
}

export default Layout
```

gatsby develop. Neu starten

![Displaying a map on the index page](images/bloggatsby3.png)

Displaying a map on the index page

A few things happening here. First, you will need to create a free [maplibre](https://maplibre/) account to get an `accessToken` to be able to use the map on your website. I think their free plan is very generous for doing all the local development as well as publishing small personal projects.

I am using React hooks - `useRef()` to access the map container DOM element. `useState()` to store the map object as a state so that I can use the value in other parts of the component, and `useEffect()` to create the map object when the component mounts. The empty dependency array as second argument to the `useEffect()` is important. I made many mistakes with this argument throughout the project. If you remove the second argument you will notice it will go into an endless loop. This is because `useEffect()` runs whenever there is a change in states, and because we are using `setMap(map)` inside the same hook, it keeps on running and running again. By having the empty array, the effect hook will only run once when the component mounts, which is what we need because we only want to create a new map once and use the same map afterwards. `return () => map.remove()` is to clean up when the component unmounts.

## Add Place Markers


Now, let's add some markers on the map. Each blog post will contain an array of places data and I want to create a marker for each. Eventually, this will be handled through the frontmatter of Markdown files, but for now, let's create a simple object with the coordinates as data source.[-0.687787, 38.185674462487874]

```
// on top of map.js
const places = [
  {
    name: "Spanien",
    longitude: -0.687787,
    latitude: 38.185674462487874,
  },
  {
    name: "Germany",
    longitude: 7.587787,
    latitude: 50.7438,
  },
  {
    name: "Frankreich",
    longitude: 3.687787,
    latitude: 45.753,
  },
]
```

I am manually creating data for each place. I got the coordinates by right-clicking on Google map. What would be much better is that we supply the name or address of a place, and let the API figure out the coordinates. That is what I eventually ended up implementing, but I am not covering it here to keep this post concise. If you're interested in it, take a look at [Nominatim](https://nominatim.org/), which does exactly that. One mistake I made was to try using batch geocoding. 

Now, back to our markers... I will create new components `Marker` and `Markers` in a file `markers.js`

```
// markers.js
import React, { useRef, useEffect } from "react"
import maplibregl from "maplibre-gl"

const Marker = ({ map, place }) => {
  const markerRef = useRef()

  useEffect(() => {
    const marker = new maplibregl.Marker(markerRef)
      .setLngLat([place.longitude, place.latitude])
      .addTo(map)

    return () => marker.remove()
  })

  return <div ref={markerRef} />
}

const Markers = ({ map, places }) => {
  return (
    <>
      {places &&
        places.map(place => (
          <Marker key={place.name} map={map} place={place} />
        ))}
    </>
  )
}

export default Markers
```

I am taking a very similar approach to what I have done to the Map component. the `Markers` component will get two props from the `Map` component - a reference to the map and the places data, which will be passed onto the `Marker` components, which will handle adding each marker to the map.

Now, we need to use the `Markers` component in the `Map` component. But before that, I will use the [Turf.js library](http://turfjs.org/) to calculate the bounding box of multiple marker coordinates so that the map can re-center itself anytime markers update. I am also installing the `@turf/helpers` to convert the coordinates into geojson objects as that is what turfjs functions expect as inputs.

```
$ npm install @turf/bbox @turf/helpers
```

In the `map.js`, I will create a new `useEffect()` hook. The first effect hook we used was to run *once* to create a new map, but the markers will be created and removed many times whenever we navigate between pages, so the new effect hook with different dependency array will be necessary.

```
// in map.js

// add new modules
import React, { useRef, useEffect, useState } from "react"
import maplibregl from "maplibre-gl"
import bbox from "@turf/bbox"
import { multiPoint } from "@turf/helpers"
import Markers from "./markers"
import "maplibre-gl/dist/maplibre-gl.css"

// ... variables

const Map = () => {
	// ... ref, state, useEffect

	// add new effect hook
  useEffect(() => {
    if (!map) return

    if (places.length !== 0) {
      const coords = []
      places.forEach(place => {
        coords.push([place.longitude, place.latitude])
      })
      const feature = multiPoint(coords)
      const box = bbox(feature)

      map.fitBounds(
        [
          [box[0], box[1]],
          [box[2], box[3]],
        ],
        {
          padding: 20,
          maxZoom: 14,
          duration: 2000,
        }
      )
    } else {
      map.easeTo({
        center: [-73.9856, 40.7497],
        zoom: 10,
        duration: 2000,
      })
    }
  }, [map])

  return (
    <div ref={mapContainerRef} style={mapContainerStyle}>
      {places && map && <Markers map={map} places={places} />}
    </div>
  )
}

export default Map
```

![Newly added markers. Animation transition is a bonus.](images/bloggatsby4.png)

We now have markers on the map for a place in Spainien, einen in Frankreich und einen in Deutschland. Play with `places` array to add more markers. What is really nice about maplibre is that it provides very useful methods like `fitBounds()` and `easeTo()`, and with the latter, we get a smooth transition animation for free. There are more animation options you can add. I encourage you to look at the maplibre documentation.

## Add Markdown Files


It's time to use the data from real blog posts instead of a simple `places` object. I created a few Markdown `.md` files in the `content` folder with the frontmatter that includes the places data. Here is an example (`content/1.md`):

```
---
title: First Day in New York
date: 2020-12-27
places:
- {
	name: "Empire State Building",
	longitude: -73.9856,
	latitude: 40.7497,
}
- {
	name: "Birch Coffee",
	longitude: -73.9864,
	latitude: 40.7438,
}
---

I went to the Empire State Building and had a coffee at Birch Coffee.
```

## Generate Pages through Gatsby Node API


To generate pages from Markdown pages in Gatsby, there are a few extra steps to take. This is another topic so I won't explain much other than showing you the code necessary to run our project.

Install a Gatsby plugin.

```
$ npm install gatsby-transformer-remark
```

Then, update `gatsby-config.js` to include the plugin, `gatsby-transformer-remark`.

Then, update `gatsby-node.js`.

```
// gatsby-node.js Ist die vollstädnig?
const path = require('path')
const { createFilePath } = require(`gatsby-source-filesystem`)

exports.onCreateNode = ({ node, getNode, actions }) => {
  const { createNodeField } = actions
  if (node.internal.type === 'MarkdownRemark') {
    const slug = createFilePath({ node, getNode })
    createNodeField({
      node,
      name: `slug`,
      value: slug
    })
  }
}

exports.createPages = async ({ graphql, actions }) => {
  const { createPage } = actions
  const result = await graphql(`
    query {
      allMarkdownRemark {
        edges {
          node {
            fields {
              slug
            }
          }
        }
      }
    }
  `)

  result.data.allMarkdownRemark.edges.forEach(({ node }) => {
    createPage({
      path: node.fields.slug,
      component: path.resolve(`./src/templates/postTemplate.js`),
      context: {
        slug: node.fields.slug
      }
    })
  })
}
```

We need `./src/templates/postTemplate.js`, which will be used as a template for our Markdown files.

```
// postTemplate.js
import React from 'react'
import { Link, graphql } from 'gatsby'
import Layout from "../components/layout"

const PostTemplate = ({ data }) => {
  const frontmatter = data.markdownRemark.frontmatter
  const html = data.markdownRemark.html

  return (
    <Layout>
      <div>
        <h1>{frontmatter.title}</h1>
        <div dangerouslySetInnerHTML={{ __html: html }} />
      </div>
      <Link to='/'>Back to Index</Link>
    </Layout>
  )
}

export default PostTemplate

export const pageQuery = graphql`
  query($slug: String!) {
    markdownRemark(fields: { slug: { eq: $slug }}) {
      html
      frontmatter {
        title
        places {
          name
          longitude
          latitude
        }
      }
    }
  }
`
```



## Add Navigation


At this point, you will need to restart the development server because we updated the `gatsby-node.js`. If everything goes well, Gatsby will generate pages for you. Let's add a simple navigation in a new `PostList` component in `postList.js` We use `useStaticQuery` to make GraphQL queries from a component, not from a page.

//todo wohin kommt die datei Verzeichnis?

```
// postList.js
import React from "react"
import { Link, graphql, useStaticQuery } from "gatsby"

const query = graphql`
  query MyQuery {
    allMarkdownRemark {
      nodes {
        frontmatter {
          title
        }
        fields {
          slug
        }
      }
    }
  }
`

const PostList = () => {
  const data = useStaticQuery(query)
  const nodes = data.allMarkdownRemark.nodes

  return (
    <ul
      style={{
        listStyleType: "none",
        padding: 0,
      }}
    >
      {nodes.map(node => {
        const title = node.frontmatter.title
        return (
          <li key={title}>
            <Link to={node.fields.slug}>{title}</Link>
          </li>
        )
      })}
    </ul>
  )
}

export default PostList
```

And include it in `layout.js`

```
// layout.js
import React from "react"
import PropTypes from "prop-types"
import Map from "./map"
import PostList from './postList'

const Layout = ({ children }) => {
  return (
    <>
      <Map />
      <div style={{ margin: '0 40px' }}>
        <main>{children}</main>
        <PostList />
      </div>
    </>
  )
}

Layout.propTypes = {
  children: PropTypes.node.isRequired,
}

export default Layout
```

We can now navigate between pages, but There are a few issues. First, on each page load, the map reloads, which causes unnecessary API calls and also break the user experience. Another ovbious issue is that the markers on all pages are the same because we have not yet connected GraphQL query data back to our map component. We will need props to handle that.

## Gatsby Browser API


At first, I thought that the `Layout` component will not reload on every page because it is wrapping the children, but later discovered that's not the case as you can see from [the Gatsby website's explanation](https://www.gatsbyjs.com/docs/how-to/routing/layout-components/#how-to-prevent-layout-components-from-unmounting). We will need to remove the wrapping `Layout` component from our pages and use the `wrapPageElement` browser API in `gatsby-browser.js`. I never used this API before so it was a learning experience. The implementation itself is very simple, and you can find more info on [the API reference](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/#wrapPageElement). You also want to use the exact same code in `gatsby-ssr.js` for Server-Side Rendering.

```
// gatsby-browser.js & gatsby-ssr.js
const React = require('react')
const Layout = require('./src/components/layout').default

exports.wrapPageElement = ({ element, props }) => {
  return <Layout {...props}>{element}</Layout>
}
```

Don't forget to remove all the layout components you are using in each page and template, otherwise, you will see the map rendered twice. Now, when you navigate between pages, the map stays the same. What's nice is that you can still use any props that your page receives and pass them to the layout. We need this to pass the places data from our page to the map in the `Layout` component.

![Pages and navigation and no reload](images/bloggatsby5.png)


## Update Map Component To Use Props


To send differen places data from each page to our `Map` component, we need to update the `Map` component to take props.

```
// in map.js

// ... remove const places

// add props & update places to props.places
const Map = props => {
	// ...

  useEffect(() => {
    if (!map) return

    if (props.places && props.places.length !== 0) {
      const coords = []
      props.places.forEach(place => {
        coords.push([place.longitude, place.latitude])
      })
      const feature = multiPoint(coords)
      const box = bbox(feature)

      map.fitBounds(
        [
          [box[0], box[1]],
          [box[2], box[3]],
        ],
        {
          padding: 20,
          maxZoom: 14,
          duration: 2000,
        }
      )
    } else {
      map.easeTo({
        center: [-73.9856, 40.7497],
        zoom: 10,
        duration: 2000,
      })
    }
  }, [map, props.places])

  return (
    <div ref={mapContainerRef} style={mapContainerStyle}>
      {props.places && map && <Markers map={map} places={props.places} />}
    </div>
  )
}
```

## Send Places Data to Layout Component


Lastly, send the places data to the `Layout` component, which will then be passed onto the `Map` component. I am using `useState()` hook because places data will be different for each page and I need to update the values accordingly. `useEffect()` hook will make sure it is updated only when `props` are updated.

```
// layout.js
import React, { useState, useEffect } from "react"
import PropTypes from "prop-types"
import Map from "./map"
import PostList from './postList'

const Layout = props => {
  const children = props.children
  const [places, setPlaces] = useState([])

  useEffect(() => {
    if (props && props.data) {
      setPlaces(props.data.markdownRemark.frontmatter.places)
    } else {
      setPlaces([])
    }
  }, [props])

  return (
    <>
      <Map places={places} />
      <div style={{ margin: '0 40px' }}>
        <main>{children}</main>
        <PostList />
      </div>
    </>
  )
}

Layout.propTypes = {
  children: PropTypes.node.isRequired,
}

export default Layout
```

![Now, we can update data and markers properly.](https://astridx.com/static/e33de6aab7dfb7c5d4db68411f7da286/d5bfb/correct-markers.png "Now, we can update data and markers properly.")

Now, we can update data and markers properly.

That's it! And here is a repo with the complete code.

<https://github.com/astridx/gatsby-maplibre-blog>

This is a bare bone structure and I hope you can make it more usable and pleasant to look at. There is basically no styling because I wanted to keep it simple and focus on the main task. Feel free to use it to make your own website.

## Nächste Schritte

Ich habe durch die Arbeit an diesem Projekt eine Menge gelernt, vor allem darüber, wie man die React Hooks verwendet - was man in `useRef()` oder `useState()` speichert und wann man `useEffect()` aufruft. Ich freue mich auf weitere Experimente mit maplibre und hier sind ein paar Ideen, die ich in Angriff nehmen werde.

- Popup für jede Markierung hinzufügen
- Hinzufügen eines eigenen Markierungsdesigns (z.B. SVG)
- Hinzufügen von Marker-Animationen
- Hinzufügen von benutzerdefinierten Kartenstilen

## Referenzen


Hier sind einige Referenzen, die ich sehr nützlich fand.

-   [maplibre React examples repo](https://github.com/maplibre/maplibre-react-examples): There are only a few examples but I got a lot of help from the repo as they covered almost everything I needed to know.
-   [maplibre examples](https://docs.maplibre.com/maplibre-gl-js/example/): Most of them are in vanilla JS but using the hooks we covered in this post, I think it would be fairly simple to translate them to React.