---
date: 2021-11-07
title: 'Gatsby Blog mit maplibre GL JS unter Verwendung von React Hooks'
template: post
thumbnail: '../../thumbnails/maplibre.png'
slug: maplibre-blog-with-gatsby
langKey: de
categories:
  - MaplibreGL
tags:
  - MaplibreGL
  - geografische Daten
  - Geoinformationssystem
  - JavaScript-Bibliothek
  - Vektor-Tiles
  - Karten
  - Gatsby
---


Ich gestalte gerne Webseiten mit [Gatsby](https://www.gatsbyjs.com/) und habe vor kurzem angefangen, [MapLibre GL](https://maplibre.org/) zu benutzen. Ich wünsche mir, beides zu kombinieren. Die Idee ist, einen Reiseblog zu erstellen, bei dem die Karte den Textinhalt verdeutlicht, indem sie dynamisch in den relevanten Bereich zoomt. Idealerweise werden die Orte aus einem Blogbeitrag mit einem Marker markiert. Beim Navigieren zwischen verschiedenen Beiträgen hebt die digitale Map kontinuierlich die neuen Bereiche hervor, anstatt jedes Mal die gesamte Karte zu aktualisieren. Dadurch ist es für den Leser leichter, den räumlicher Kontext zu erkennen. Beim Bearbeiten dieses Projekts bin ich über die ein- oder anderen Hürde  gestolpert. Die Erkenntnisse, die ich dabei bisher gewonnen habe, werde ich hervorheben.

## Einrichtung

Im nachfolgenden Beispielcode gehe ich nicht auf jede einzelne Codezeile ein. Dafür stelle ich das Ergebnis online in meinem [Github Repo](https://github.com/astridx/gatsby-maplibre-blog-tutorial) zur Verfügung. Der Branch `main` ist für MapLibre GL in Version 1.x erstellt. Der Branch `test_maplibre_v2` enthält Ergänzungen für MapLibre GL 2.x. Ich gehe davon aus, dass du mit Gatsby und React vertraut bist und die grundlegenden Abhängigkeiten installiert hast.

> Erste Schritte mit [React](https://de.reactjs.org/docs/getting-started.html) oder [Gatsby](https://www.gatsbyjs.com/docs/tutorial/)

Als erstes erstellen wir ein leeres Gatsby-Projekt. Ich verwende das von Gatsby zur Verfügung gestellt [Startprojekt](https://www.gatsbyjs.com/docs/starters/). So ist das Wesentliche vorkonfiguriert. Das Endergebnis dieses Tutorials ist eine Boilerplate-Struktur. Passe die im Anschluß gerne an deine individuellen Bedürfnisse an.

```
$ gatsby new gatsby-maplibre-blog
```

Nachdem du das Projekt erstellt hast, wechsele mittels `cd gatsby-maplibre-blog` in das Projektverzeichnis und rufe `gatsby develop` auf. Als Ergebnis siehst du die folgende Ausgabe unter der URL `http://localhost:8000/` im Browser:

![Ein Bildschirmfoto des Gatsby-Standard-Starters](images/bloggatsby1.png)

Um etwas aufzuräumen habe ich im Ordner `src` die Dateien `components/layout.js`, `pages/404.js` und `pages/index.js` abgeändert. 

> Wenn du mit Gatsby vertraut bist, kannst du auch noch weitere Inhalte des Boilerplates löschen. Um diese Beispiel übersichtlich zu halten, reicht das Ändern der Dateien `components/layout.js`, `pages/404.js` und `pages/index.js` aus.

```js
// index.js
import React from "react"
import Layout from "../components/layout"

const IndexPage = () => (
  <Layout>
    <h1>Reise Blog</h1>
  </Layout>
)

export default IndexPage
```

```js
// layout.js
import React from "react"
import PropTypes from "prop-types"

const Layout = ({ children }) => {
  return (
      <div>
        <main>{children}</main>
      </div>
  )
}

Layout.propTypes = {
  children: PropTypes.node.isRequired,
}

export default Layout
```

```js
// 404.js
import React from "react"

const NotFoundPage = () => (
  <>
    <h1>Page Not Found</h1>
  </>
)

export default NotFoundPage
```

Weiterhin habe ich die Datei `gatsby-config.js` aufgeräumt. Auch hier wollte ich mit einem Minimum beginnen. Somit habe ich eine Menge entfernt und den Quellpfad der Datei in `content` geändert. Zusätzlich stelle ich sicher, dass es den Ordner namens `content` im Stammverzeichnis meines Projekts gibt. Weil es ihn im Projekt noch nicht gibt, lege ich ihn an. Wir benötigen ihn im Moment nicht, aber hier werde ich später Markdown-Dateien für Blogbeiträge anlegen.

```js
// gatsby-config.js
module.exports = {
  siteMetadata: {
    title: `Gatsby maplibre Blog`,
    description: ``,
    author: `Me`,
  },
  plugins: [
    `gatsby-plugin-react-helmet`,
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `content`,
        path: `${__dirname}/content`,
      },
    },
    `gatsby-transformer-sharp`,
    `gatsby-plugin-sharp`,
  ],
}
```

Starte an dieser Stelle den Entwicklungsserver neu, um sicherzustellen, dass kein Fehler vorliegt. Führe `gatsby develop` erneut aus. Wenn du keine Fehlermeldungen siehst ist alles gut.

![A screenshot of Gatsby default starter after tidy up](images/bloggatsby2.png)

## Install maplibre

We will install maplibre GL JS from NPM. There are a few maplibre wrapper projects, that give you many React components to use, and I have tried one but I felt a bit difficult to customize (due to my lack of understanding, not the fault of the library), and maplibre has a lot of official code examples based on vanilla JS so I thought I would give some time to learn to combine vanilla JS and React components myself. Nebenbei bleibe ich unabhängig.

You can follow [their guide](https://www.npmjs.com/package/maplibre-gl) but basically, you only need to run this command in the terminal:

```
$ npm i maplibre-gl
```

*Note: The current verion of `maplibre-gl` is `2.0.0-pre.6` at the time of writing.*

It also needs a stylesheet to display the map properly. You can include this CSS in the `<head>` of any HTML page using a map, but I will later add it in my component by directly importing from the npm module. It's up to you.

```
<link href='https://unpkg.com/maplibre-gl@1.15.2/dist/maplibre-gl.css' rel='stylesheet' />
```
> https://github.com/maplibre/maplibre-gl-js/blob/main/docs/README-unpkg.md

## Display The Map


I want the same map to be shared across multiple blog posts, so instead of adding a map on every page, I will instead add it the the `Layout` component, because every page that I will be creating will be wrapped with the component. And to keep the code clean and reusable, I will make a separate component called `Map`. Let's create `components/map.js`.

```
// map.js
import React, { useRef, useEffect, useState } from "react"
import maplibregl from "maplibre-gl"
import "maplibre-gl/dist/maplibre-gl.css"

const mapContainerStyle = {
  width: "100%",
  height: "120px",
}

const Map = () => {
  const mapContainerRef = useRef(null)

  const [map, setMap] = useState(null)

  useEffect(() => {
    const map = new maplibregl.Map({
      container: mapContainerRef.current,
      style: 'https://demotiles.maplibre.org/style.json',
      center: [-0.687787, 38.185674462487874],
      zoom: 10,
    })
    map.addControl(new maplibregl.NavigationControl(), "top-right")

    setMap(map)

    return () => map.remove()
  }, [])

  return <div ref={mapContainerRef} style={mapContainerStyle} />
}

export default Map
```

> https://maplibre.org/maplibre-gl-js-docs/example/simple-map/  Demotiles and keys

And include a Map component in `layout.js`

```
// layout.js
import React from "react"
import PropTypes from "prop-types"
import Map from "./map"

const Layout = ({ children }) => {
  return (
    <>
      <Map />
      <main>{children}</main>
    </>
  )
}

Layout.propTypes = {
  children: PropTypes.node.isRequired,
}

export default Layout
```

gatsby develop. Neu starten

![Displaying a map on the index page](images/bloggatsby3.png)

Displaying a map on the index page

A few things happening here. First, you will need to create a free [maplibre](https://maplibre/) account to get an `accessToken` to be able to use the map on your website. I think their free plan is very generous for doing all the local development as well as publishing small personal projects.

I am using React hooks - `useRef()` to access the map container DOM element. `useState()` to store the map object as a state so that I can use the value in other parts of the component, and `useEffect()` to create the map object when the component mounts. The empty dependency array as second argument to the `useEffect()` is important. I made many mistakes with this argument throughout the project. If you remove the second argument you will notice it will go into an endless loop. This is because `useEffect()` runs whenever there is a change in states, and because we are using `setMap(map)` inside the same hook, it keeps on running and running again. By having the empty array, the effect hook will only run once when the component mounts, which is what we need because we only want to create a new map once and use the same map afterwards. `return () => map.remove()` is to clean up when the component unmounts.

## Add Place Markers


Now, let's add some markers on the map. Each blog post will contain an array of places data and I want to create a marker for each. Eventually, this will be handled through the frontmatter of Markdown files, but for now, let's create a simple object with the coordinates as data source.[-0.687787, 38.185674462487874]

```
// on top of map.js
const places = [
  {
    name: "Spanien",
    longitude: -0.687787,
    latitude: 38.185674462487874,
  },
  {
    name: "Germany",
    longitude: 7.587787,
    latitude: 50.7438,
  },
  {
    name: "Frankreich",
    longitude: 3.687787,
    latitude: 45.753,
  },
]
```

I am manually creating data for each place. I got the coordinates by right-clicking on Google map. What would be much better is that we supply the name or address of a place, and let the API figure out the coordinates. That is what I eventually ended up implementing, but I am not covering it here to keep this post concise. If you're interested in it, take a look at [Nominatim](https://nominatim.org/), which does exactly that. One mistake I made was to try using batch geocoding. 

Now, back to our markers... I will create new components `Marker` and `Markers` in a file `markers.js`

```
// markers.js
import React, { useRef, useEffect } from "react"
import maplibregl from "maplibre-gl"

const Marker = ({ map, place }) => {
  const markerRef = useRef()

  useEffect(() => {
    const marker = new maplibregl.Marker(markerRef)
      .setLngLat([place.longitude, place.latitude])
      .addTo(map)

    return () => marker.remove()
  })

  return <div ref={markerRef} />
}

const Markers = ({ map, places }) => {
  return (
    <>
      {places &&
        places.map(place => (
          <Marker key={place.name} map={map} place={place} />
        ))}
    </>
  )
}

export default Markers
```

I am taking a very similar approach to what I have done to the Map component. the `Markers` component will get two props from the `Map` component - a reference to the map and the places data, which will be passed onto the `Marker` components, which will handle adding each marker to the map.

Now, we need to use the `Markers` component in the `Map` component. But before that, I will use the [Turf.js library](http://turfjs.org/) to calculate the bounding box of multiple marker coordinates so that the map can re-center itself anytime markers update. I am also installing the `@turf/helpers` to convert the coordinates into geojson objects as that is what turfjs functions expect as inputs.

```
$ npm install @turf/bbox @turf/helpers
```

In the `map.js`, I will create a new `useEffect()` hook. The first effect hook we used was to run *once* to create a new map, but the markers will be created and removed many times whenever we navigate between pages, so the new effect hook with different dependency array will be necessary.

```
// in map.js

// add new modules
import React, { useRef, useEffect, useState } from "react"
import maplibregl from "maplibre-gl"
import bbox from "@turf/bbox"
import { multiPoint } from "@turf/helpers"
import Markers from "./markers"
import "maplibre-gl/dist/maplibre-gl.css"

// ... variables

const Map = () => {
	// ... ref, state, useEffect

	// add new effect hook
  useEffect(() => {
    if (!map) return

    if (places.length !== 0) {
      const coords = []
      places.forEach(place => {
        coords.push([place.longitude, place.latitude])
      })
      const feature = multiPoint(coords)
      const box = bbox(feature)

      map.fitBounds(
        [
          [box[0], box[1]],
          [box[2], box[3]],
        ],
        {
          padding: 20,
          maxZoom: 14,
          duration: 2000,
        }
      )
    } else {
      map.easeTo({
        center: [-73.9856, 40.7497],
        zoom: 10,
        duration: 2000,
      })
    }
  }, [map])

  return (
    <div ref={mapContainerRef} style={mapContainerStyle}>
      {places && map && <Markers map={map} places={places} />}
    </div>
  )
}

export default Map
```

![Newly added markers. Animation transition is a bonus.](images/bloggatsby4.png)

We now have markers on the map for a place in Spainien, einen in Frankreich und einen in Deutschland. Play with `places` array to add more markers. What is really nice about maplibre is that it provides very useful methods like `fitBounds()` and `easeTo()`, and with the latter, we get a smooth transition animation for free. There are more animation options you can add. I encourage you to look at the maplibre documentation.

## Add Markdown Files


It's time to use the data from real blog posts instead of a simple `places` object. I created a few Markdown `.md` files in the `content` folder with the frontmatter that includes the places data. Here is an example (`content/1.md`):

```
---
title: First Day in New York
date: 2020-12-27
places:
- {
	name: "Empire State Building",
	longitude: -73.9856,
	latitude: 40.7497,
}
- {
	name: "Birch Coffee",
	longitude: -73.9864,
	latitude: 40.7438,
}
---

I went to the Empire State Building and had a coffee at Birch Coffee.
```

## Generate Pages through Gatsby Node API


To generate pages from Markdown pages in Gatsby, there are a few extra steps to take. This is another topic so I won't explain much other than showing you the code necessary to run our project.

Install a Gatsby plugin.

```
$ npm install gatsby-transformer-remark
```

Then, update `gatsby-config.js` to include the plugin, `gatsby-transformer-remark`.

Then, update `gatsby-node.js`.

```
// gatsby-node.js Ist die vollstädnig?
const path = require('path')
const { createFilePath } = require(`gatsby-source-filesystem`)

exports.onCreateNode = ({ node, getNode, actions }) => {
  const { createNodeField } = actions
  if (node.internal.type === 'MarkdownRemark') {
    const slug = createFilePath({ node, getNode })
    createNodeField({
      node,
      name: `slug`,
      value: slug
    })
  }
}

exports.createPages = async ({ graphql, actions }) => {
  const { createPage } = actions
  const result = await graphql(`
    query {
      allMarkdownRemark {
        edges {
          node {
            fields {
              slug
            }
          }
        }
      }
    }
  `)

  result.data.allMarkdownRemark.edges.forEach(({ node }) => {
    createPage({
      path: node.fields.slug,
      component: path.resolve(`./src/templates/postTemplate.js`),
      context: {
        slug: node.fields.slug
      }
    })
  })
}
```

We need `./src/templates/postTemplate.js`, which will be used as a template for our Markdown files.

```
// postTemplate.js
import React from 'react'
import { Link, graphql } from 'gatsby'
import Layout from "../components/layout"

const PostTemplate = ({ data }) => {
  const frontmatter = data.markdownRemark.frontmatter
  const html = data.markdownRemark.html

  return (
    <Layout>
      <div>
        <h1>{frontmatter.title}</h1>
        <div dangerouslySetInnerHTML={{ __html: html }} />
      </div>
      <Link to='/'>Back to Index</Link>
    </Layout>
  )
}

export default PostTemplate

export const pageQuery = graphql`
  query($slug: String!) {
    markdownRemark(fields: { slug: { eq: $slug }}) {
      html
      frontmatter {
        title
        places {
          name
          longitude
          latitude
        }
      }
    }
  }
`
```



## Add Navigation


At this point, you will need to restart the development server because we updated the `gatsby-node.js`. If everything goes well, Gatsby will generate pages for you. Let's add a simple navigation in a new `PostList` component in `postList.js` We use `useStaticQuery` to make GraphQL queries from a component, not from a page.

//todo wohin kommt die datei Verzeichnis?

```
// postList.js
import React from "react"
import { Link, graphql, useStaticQuery } from "gatsby"

const query = graphql`
  query MyQuery {
    allMarkdownRemark {
      nodes {
        frontmatter {
          title
        }
        fields {
          slug
        }
      }
    }
  }
`

const PostList = () => {
  const data = useStaticQuery(query)
  const nodes = data.allMarkdownRemark.nodes

  return (
    <ul
      style={{
        listStyleType: "none",
        padding: 0,
      }}
    >
      {nodes.map(node => {
        const title = node.frontmatter.title
        return (
          <li key={title}>
            <Link to={node.fields.slug}>{title}</Link>
          </li>
        )
      })}
    </ul>
  )
}

export default PostList
```

And include it in `layout.js`

```
// layout.js
import React from "react"
import PropTypes from "prop-types"
import Map from "./map"
import PostList from './postList'

const Layout = ({ children }) => {
  return (
    <>
      <Map />
      <div style={{ margin: '0 40px' }}>
        <main>{children}</main>
        <PostList />
      </div>
    </>
  )
}

Layout.propTypes = {
  children: PropTypes.node.isRequired,
}

export default Layout
```

We can now navigate between pages, but There are a few issues. First, on each page load, the map reloads, which causes unnecessary API calls and also break the user experience. Another ovbious issue is that the markers on all pages are the same because we have not yet connected GraphQL query data back to our map component. We will need props to handle that.

## Gatsby Browser API


At first, I thought that the `Layout` component will not reload on every page because it is wrapping the children, but later discovered that's not the case as you can see from [the Gatsby website's explanation](https://www.gatsbyjs.com/docs/how-to/routing/layout-components/#how-to-prevent-layout-components-from-unmounting). We will need to remove the wrapping `Layout` component from our pages and use the `wrapPageElement` browser API in `gatsby-browser.js`. I never used this API before so it was a learning experience. The implementation itself is very simple, and you can find more info on [the API reference](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-browser/#wrapPageElement). You also want to use the exact same code in `gatsby-ssr.js` for Server-Side Rendering.

```
// gatsby-browser.js & gatsby-ssr.js
const React = require('react')
const Layout = require('./src/components/layout').default

exports.wrapPageElement = ({ element, props }) => {
  return <Layout {...props}>{element}</Layout>
}
```

Don't forget to remove all the layout components you are using in each page and template, otherwise, you will see the map rendered twice. Now, when you navigate between pages, the map stays the same. What's nice is that you can still use any props that your page receives and pass them to the layout. We need this to pass the places data from our page to the map in the `Layout` component.

![Pages and navigation and no reload](images/bloggatsby5.png)


## Update Map Component To Use Props


To send differen places data from each page to our `Map` component, we need to update the `Map` component to take props.

```
// in map.js

// ... remove const places

// add props & update places to props.places
const Map = props => {
	// ...

  useEffect(() => {
    if (!map) return

    if (props.places && props.places.length !== 0) {
      const coords = []
      props.places.forEach(place => {
        coords.push([place.longitude, place.latitude])
      })
      const feature = multiPoint(coords)
      const box = bbox(feature)

      map.fitBounds(
        [
          [box[0], box[1]],
          [box[2], box[3]],
        ],
        {
          padding: 20,
          maxZoom: 14,
          duration: 2000,
        }
      )
    } else {
      map.easeTo({
        center: [-73.9856, 40.7497],
        zoom: 10,
        duration: 2000,
      })
    }
  }, [map, props.places])

  return (
    <div ref={mapContainerRef} style={mapContainerStyle}>
      {props.places && map && <Markers map={map} places={props.places} />}
    </div>
  )
}
```

## Send Places Data to Layout Component


Lastly, send the places data to the `Layout` component, which will then be passed onto the `Map` component. I am using `useState()` hook because places data will be different for each page and I need to update the values accordingly. `useEffect()` hook will make sure it is updated only when `props` are updated.

```
// layout.js
import React, { useState, useEffect } from "react"
import PropTypes from "prop-types"
import Map from "./map"
import PostList from './postList'

const Layout = props => {
  const children = props.children
  const [places, setPlaces] = useState([])

  useEffect(() => {
    if (props && props.data) {
      setPlaces(props.data.markdownRemark.frontmatter.places)
    } else {
      setPlaces([])
    }
  }, [props])

  return (
    <>
      <Map places={places} />
      <div style={{ margin: '0 40px' }}>
        <main>{children}</main>
        <PostList />
      </div>
    </>
  )
}

Layout.propTypes = {
  children: PropTypes.node.isRequired,
}

export default Layout
```

![Now, we can update data and markers properly.](https://astridx.com/static/e33de6aab7dfb7c5d4db68411f7da286/d5bfb/correct-markers.png "Now, we can update data and markers properly.")

Now, we can update data and markers properly.

That's it! And here is a repo with the complete code.

<https://github.com/astridx/gatsby-maplibre-blog>

This is a bare bone structure and I hope you can make it more usable and pleasant to look at. There is basically no styling because I wanted to keep it simple and focus on the main task. Feel free to use it to make your own website.

## Nächste Schritte

Ich habe durch die Arbeit an diesem Projekt eine Menge gelernt, vor allem darüber, wie man die React Hooks verwendet - was man in `useRef()` oder `useState()` speichert und wann man `useEffect()` aufruft. Ich freue mich auf weitere Experimente mit maplibre und hier sind ein paar Ideen, die ich in Angriff nehmen werde.

- Popup für jede Markierung hinzufügen
- Hinzufügen eines eigenen Markierungsdesigns (z.B. SVG)
- Hinzufügen von Marker-Animationen
- Hinzufügen von benutzerdefinierten Kartenstilen

## Referenzen


Hier sind einige Referenzen, die ich sehr nützlich fand.

-   [maplibre React examples repo](https://github.com/maplibre/maplibre-react-examples): There are only a few examples but I got a lot of help from the repo as they covered almost everything I needed to know.
-   [maplibre examples](https://docs.maplibre.com/maplibre-gl-js/example/): Most of them are in vanilla JS but using the hooks we covered in this post, I think it would be fairly simple to translate them to React.