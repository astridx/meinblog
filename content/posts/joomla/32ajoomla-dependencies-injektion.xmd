---
date: 2021-01-01
title: 'Joomla 4.x Tutorial - Extension Development - Add a Service - Routing'
template: post
thumbnail: '../../thumbnails/joomla.png'
slug: en/joomla-einen-service-hinzufuegen-routing
langKey: en
categories:
  - JoomlaEn
  - Code
tags:
  - CMS
  - Joomla
---

Dependency Injection (DI) ist ein kompliziertes Konzept für diejenigen, die damit nicht vertraut sind. Mit einem praktischen Beispiel, werden die Vorteile schnell klar.

## Dependency Injection in Joomla nutzen






## Warum Dependency Injection



```php
Klasse Samurai
{
	private $schwert;
	private $shuriken;

	public function __construct()
	{
		$this->Schwert = new Schwert;
		$this->shuriken = new Shuriken;
	}

	public function attack($useSword = true)
	{
		if ($useSword)
		{
			$this->Schwert->Schlag();
		}
		sonst
		{
			$this->shuriken->hit();
		}
	}
}
```
```php
Klasse Schwert
{
	public function hit($target)
	{
		echo 'Triff das ' . $Ziel;
	}
}
```
```php
Klasse Shuriken
{
	public function hit($target)
	{
		echo 'Wirf Shuriken auf ' . $Ziel;
	}
}
```
```php
$Krieger = new Samurai;

// Vorbereitungen....

$warrior->attack();
```

### Die Situation

Im letzten Codeblock oben stellen Sie sich vor, Sie wären der Kommandant einer Samurai-Armee. Sie sind sich der Schlacht bewusst und wissen, was zu tun ist, um zu gewinnen, und bereiten Ihren Angriff vor. Sie weisen also einen Ihrer Krieger an, sich auf die Schlacht vorzubereiten. Während er sich vorbereitet, muss er anhalten und seine Waffen suchen, bevor er zum Angriff bereit ist. Dann steht er untätig da und wartet auf deinen Befehl, den du gibst. Er rennt mit gezücktem Schwert los, aber dann wird dir klar, dass es besser wäre, stattdessen Pfeil und Bogen zu benutzen. Aber dein Krieger wusste nicht, dass er seinen Bogen mitgebracht hatte. Die Schlacht ist verloren, weil er schlecht vorbereitet war.

### Das Problem

Da du deinem Krieger gesagt hast, er solle sich auf den Kampf vorbereiten, hat er die Gegenstände genommen, mit denen er vertraut war, und sich so gut wie möglich vorbereitet. Es ist unmöglich, dass er alle möglichen Waffen mit sich führt, die du von ihm verlangen könntest. Anstatt dem Samurai vorzuschreiben, welche Waffen er benutzen soll, wäre es natürlich besser, wenn du ihm die Waffen zur Verfügung stellen würdest.

### Die Lösung

Die beste Lösung für dieses Problem ist, ihm die Waffen während der Vorbereitung zur Verfügung zu stellen. Es gibt eine wichtige Aufgabe, die Sie erledigen müssen, um dem Samurai beizubringen, wie er jede Waffe benutzen kann, die Sie ihm zuwerfen, aber die Mühe lohnt sich.

#### Erstellen Sie eine Schnittstelle

Eine Schnittstelle ist ein Vertrag zwischen der implementierenden Klasse und der aufrufenden Klasse, der besagt, dass jede Klasse, die die Schnittstelle implementiert, bestimmte Kriterien erfüllen muss. Wir haben derzeit 2 Waffen, lass uns einen Vertrag für sie erstellen und diesen Vertrag dann in den Klassen implementieren, damit der Samurai richtig trainiert wird.

```php
Schnittstelle WeaponInterface
{
	public function hit($target);
}

class Sword implementiert WeaponInterface
{
	public function hit($target)
	{
		echo 'Getroffen ' . $Ziel;
	}
}

class Shuriken implementiert WeaponInterface
{
	public function hit($target)
	{
		echo 'Wirf Shuriken auf ' . $target;
	}
}
```

Da wir nun wissen, dass unsere Waffen eine Treffermethode haben werden, und da sie den Vertrag durch die Implementierung der Schnittstelle unterschrieben haben, können wir unseren Samurai leicht so modifizieren, dass er eine dieser Waffen erhält, während er sich vorbereitet.

```php
Klasse Samurai
{
	protected $weapon;

	public function __construct(WeaponInterface $weapon)
	{
		$this->weapon = $weapon;
	}

	public function setWeapon(WeaponInterface $weapon)
	{
		$this->Waffe = $Waffe;
	}

	public function attack($target)
	{
		$this->weapon>hit($target);
	}
}
```

Wie Sie sehen können, haben wir die Vorbereitungsarbeit, die er leisten muss, stark reduziert.

```php
$warrior = new Samurai(new Sword);

$warrior->attack('the enemy');
```

Das sind die Grundlagen von DI. Die Übergabe der Anforderungen für eine Klasse an die Klasse über ihren Konstruktor oder über eine `setProperty`-Methode, wobei "property" typischerweise dem Namen der Eigenschaft entspricht, die Sie setzen wollen, wie in der zweiten Version der Samurai-Klasse mit der `setWeapon`-Methode. Hier ist ein Beispiel, das den Setter für DI verwendet.

```php
$Krieger = neuer Samurai;

$warrior->setWeapon(new Sword);

$warrior->attack();
```

## Wie ein Container helfen kann

Ein Inversion of Control (IoC) Container kann Ihnen helfen, alle Teile der Anwendung zu verwalten. Anstatt jedes Mal einen neuen Krieger zu erstellen, wäre es für die Anwendung viel einfacher, sich zu merken, wie man einen Krieger vorbereitet und in der Lage zu sein, einen bei Bedarf zu erstellen. Da der Samurai in unserem Beispiel nicht viele Abhängigkeiten hat, sind die Vorteile eines Containers vielleicht schwer zu erkennen. Aber bedenken Sie, dass Sie jedes Mal, wenn Sie einen Krieger erstellen wollen, daran denken müssen, die Abhängigkeiten zu übergeben. Mit einem Container können Sie sozusagen ein Template einrichten und die Erstellung der Anwendung überlassen. Das ist WIRKLICH praktisch, wenn die Abhängigkeiten, die Sie injizieren, Abhängigkeiten innerhalb ihrer Abhängigkeiten haben. Es kann sehr schnell sehr kompliziert werden.

```php
$warrior = new Samurai(new Sword);
$warrior->attack();

$warrior = new Samurai(new Sword);
$Krieger->Angriff();

$Krieger = new Samurai(new Schwert);
$Krieger->Angriff();

$Krieger = new Samurai(new Schwert);
$warrior->attack();

// vs

$ioc['warrior']->attack();
$ioc['warrior']->attack();
$ioc['warrior']->attack();
$ioc['warrior']->attack();

/**
 * Dies würde in Ihrem App-Bootstrap sein
 * oder irgendwo aus dem Weg.
 */
$ioc = new Joomla\DI\Container;

$ioc->set('warrior', function ()
{
	ret

Übersetzt mit www.DeepL.com/Translator (kostenlose Version)
