---
date: 2019-08-01
title: 'ECMAScript 6 - Objekte'
template: post
thumbnail: '../thumbnails/js.png'
slug: objekte
categories:
  - JavaScript
tags:
  - ecmascript
  - javascript
---

# ECMAScript 6 - Objekte
[](#){#Objekte}


## In diesem Kapitel werden wir …
ECMAScript 6 verbessert die Arbeit mit Objekten.

## Welche Objekte gib es in JavaScript

## Syntax

Die populärste Variante ein Objekt in JavaScript zu erzeugen, ist der 
`Objekt-Literal`. 
Die Syntax des `Objekt-Literals` beginnt mit einer öffnenden 
geschweiften Klammer `{` und endet mit einer 
schließenden geschweiften Klammer `}`. Dazwischen werden die 
Eigenschaften mit Name und Wert aufgelistet. 
Zwischen dem Name der Eigenschaft und ihrem Wert steht ein 
Doppelpunkt, zwischen den Eigenschaften selbst ein Komma. 
JSON baut auf dieser Syntax auf. Das Erfolgsrezept dieser Syntax ist 
die Einfachheit, mit der ein Objekt erstellt wird. 
ECMAScript 6 verbessert das Arbeiten mit `Objekt-Literalen` noch weiter.

### Abgekürzte Syntax für Eigenschaften

Schon in ECMAScript 5 reichten einige wenige Zeilen um ein Objekt zu erstellen. 
Im nächsten Beispiel können Sie sich davon überzeugen.

```
function erstellePerson(name, alter) {
return {
name: name,
alter: alter
};
}
let person = erstellePerson("Astrid", 50);
console.log(person); // Ausgabe: Object { name: "Astrid", alter: 50 }
<!--index_935.html -->
```

Mit ECMAScript 6 wird der notwendige Programmcode noch weiter reduziert. Das 
nachfolgende Beispiel ist das ECMAScript 6 Äquivalent zum vorhergenden 
Beispiel. Sehen Sie selbst, die Namen der Eigenschaften können Sie 
im Objekt-Literal` einsparen solange Sie die Variablen die passenden Namen 
haben.

Im nächsten Beispiel haben die Variablen die gleichen Namen und 
die gleiche Reihenfolge wie im vorhergehenden.

```
function erstellePerson(name, alter) {
return {
name,
alter
};
}
let person = erstellePerson("Astrid", 50);
console.log(person); // Ausgabe: Object { name: "Astrid", alter: 50 }
<!--index_935a.html -->
```

Nachfolgend können Sie sehen was passiert, wenn Sie die Variablen in 
einer anderen Reihenfolge eingeben.

```
function erstellePerson(name, alter) {
return {
alter,
name
};
}
let person = erstellePerson("Astrid", 50);
console.log(person); // Ausgabe: Object { alter: 50, name: "Astrid" }
<!--index_935b.html -->
```

Wenn sie andere Variablennamen verwenden, wird ihr Ergebnis ein Objekt 
mit anderen Eigenschaften sein.

```
function erstellePerson(name, alter) {
let age = alter;	
return {
age,
name
};
}
let person = erstellePerson("Astrid", 50);
console.log(person); // Ausgabe: Object { age: 50, name: "Astrid" }
<!--index_935c.html -->
```

### Abgekürzte Syntax für Methoden

Auch Methoden können Sie in abgekürzter Form in einem `Object-Literal` 
verwenden.

```
<!--index_934.html -->
```

```
<!--index_934a.html -->
```

### Namen von Eigenschaften im Objekt-Literal

Die Namen von Eigenschaften konnten nicht berechnet werden.

```
let person = {};
let nachname = "nach name";
person["vor name"] = "astrid";
person[nachname] = "guenther";
person["geburts name"] = "mueller";

console.log(person["vor name"]); // Ausgabe: astrid
console.log(person[nachname]); // Ausgabe: guenther
console.log(person["geburts name"]); // Ausgabe: mueller
<!--index_933.html -->
```

```
let nachname = "nach name";
let person = {
	"vor name": "astrid",
	nachname: "guenther",
	"geburts name": "mueller",
};

console.log(person["vor name"]); // Ausgabe: astrid
console.log(person[nachname]); // Ausgabe: undefind
console.log(person["geburts name"]); // Ausgabe: mueller
<!--index_933a.html -->
```

```
let nachname = "nach name";
let person = {
	"vor name": "astrid",
	"geburts name": "mueller",
};
person[nachname] = "guenther";
console.log(person["vor name"]); // Ausgabe: astrid
console.log(person[nachname]); // Ausgabe: guenther
console.log(person["geburts name"]); // Ausgabe: mueller
<!--index_933b.html -->
```

Im Objekt-Literal können mit ECMAScript 6 eckige Klammern verwendet werden.

```
let nachname = "nach name";
let person = {
	"vor name": "astrid",
	[nachname]: "guenther",
	"geburts name": "mueller",
};
console.log(person["vor name"]); // Ausgabe: astrid
console.log(person[nachname]); // Ausgabe: guenther
console.log(person["geburts name"]); // Ausgabe: mueller
<!--index_933c.html -->
```

## Neue Methoden
### is()

Object.is() bestimmt, ob zwei Werte gleich sind. Dabei gelten zwei 
Werte genau dann als gleich, wenn eine der folgenden Bedingungen zutrifft:

- beide sind undefined
- beide sind null
- beide sind true oder beide sind false
- beide sind Strings mit selber Länge und den selben Zeichen
- beide sind das selbe Objekt
- beide sind Zahlen und eine der folgenden Bedingungen trifft zu:
  - beide sind +0
  - beide sind -0
  - beide sind NaN
  - beide sind nicht null, beide sind nicht NaN und beide haben den selben Zahlenwert

Dies ist nicht das selbe wie der ==-Operator. Dieser verwendet verschiedene, situationsabhängige Typ-Umwandlungen auf beiden Seiten bevor auf Gleichheit getestet wird (was z.B. dazu führt, dass der Ausdruck "" == false zu true ausgewertet wird). Object.is hingegen wandelt keinen der beiden Werte um.

Es ist ebenfalls nicht dasselbe wie der strikte `===`-Operator. 
Dieser – ebenso wie der `==`-Operator – behandelt zum Beispiel `+0` und `-0` als 
identisch während `NaN` und `NaN` als nicht identisch behandelt werden.
https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/is

Jeder der Operatoren hat seine Vorteile und seine Nachteile. 
Hier gibt es kein Richtig oder Falsch. Entscheiden Sie selbst 
welcher Vergleichsoperator der 
Richtige für Ihren aktuellen Anendungsfall ist.

```
console.log(0 == 0); // Ausgabe: true
console.log(0 == "0"); // Ausgabe: true
console.log(0 === 0); // Ausgabe: true
console.log(0 === "0"); // Ausgabe: false
console.log(Object.is(0, 0)); // Ausgabe: true
console.log(Object.is(0, "0")); // Ausgabe: false

console.log(+0 == -0); // Ausgabe: true
console.log(+0 === -0); // Ausgabe: true
console.log(Object.is(+0, -0)); // Ausgabe: false

console.log(NaN == NaN); // Ausgabe: false
console.log(NaN === NaN); // Ausgabe: false
console.log(Object.is(NaN, NaN)); // Ausgabe: true
<!--index_932.html -->
```

### assign()

Die Methode Object.assign() kopiert die Werte aller aufzählbaren, eigenen Eigenschaften von einem oder mehreren Quellobjekten in ein Zielobjekt. 
Es wird das Zielobjekt zurückgegeben. https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

Aber beginnen wir ganz vorne - hier bei Mixins. 
Ein Mixin ist eine Klasse oder eine Schnittstelle in der einige oder 
alle ihrer Methoden und/oder Eigenschaften nicht implementiert werden, 
was erfordert, dass eine andere Klasse oder Schnittstelle die fehlenden 
Implementierungen bereitstellt. 
Die neue Klasse bzw. die neue Schnittstelle enthält dann sowohl 
die Eigenschaften und Methoden aus dem Mixin als auch diejenigen, 
die sie selbst definiert. Alle Methoden und Eigenschaften werden exakt 
gleich verwendet, unabhängig davon, ob sie im Mixin implementiert 
sind oder im Interface oder in der Klasse, die das Mixin implementiert. 
Der Vorteil von Mixins besteht darin, dass sie zur Vereinfachung 
des Designs von APIs verwendet werden können, 
bei denen mehrere Schnittstellen dieselben Methoden 
und Eigenschaften enthalten müssen. https://developer.mozilla.org/de/docs/Glossary/Mixin

Vielleicht ist Ihnen schon einmal ein Mixin wie das Folgende aufgefallen?

```
function mixin(receiver, supplier) {
    Object.keys(supplier).forEach(function(key) {
        receiver[key] = supplier[key];
    });

    return receiver;
}
function EreignisZiel(){
}
EreignisZiel.prototype ={
constructor: EreignisZiel,
sage: function(wort){
console.log(wort);
},
};
let meinObjekt = {};
mixin(meinObjekt, EreignisZiel.prototype);
meinObjekt.sage("Hallo"); // Ausgabe: Hallo
<!--index_931.html -->
```

Im nächsten Beispiel sehen Sie, dass die Methode assign() die Aufgabe der 
selbstgeschriebenen Methode mixin übernimmt. Sie müssen ein Mixin nicht 
mehr selbst programmieren. ECMAScript 6 bietet Ihnen dies von Hause aus.

```
function EreignisZiel(){
}
EreignisZiel.prototype ={
constructor: EreignisZiel,
sage: function(wort){
console.log(wort);
},
};
let meinObjekt = {};
Object.assign(meinObjekt, EreignisZiel.prototype);
meinObjekt.sage("Hallo"); // Ausgabe: Hallo
<!--index_931a.html -->
```

Achtung überschreiben.

```
let meinObjekt = {};
Object.assign(meinObjekt, 
{id: "1"},
{id: "2"}
);
console.log(meinObjekt.id); // Ausgabe: 2
<!--index_931b.html -->
```

Nur der Wert wird zugewiesen, nicht die Methode.

```
let meinObjekt = {};
Object.assign(meinObjekt, 
{get id() {return "1"}},
{get id() {return "2"}}
);
console.log(meinObjekt.id); // Ausgabe: 2
console.log(meinObjekt.get); // Ausgabe: undefined
<!--index_931c.html -->
```

## Duplicate Objekt literals

Mit ECMAScript 6 darf man in einem Objekt-Literal eine Eigenschaft mit dem 
gleichen Namen mehrmals einfügen. Zum Beispiel so wie im folgenden 
Programmcode.

```
"use strict";
let meinObjekt = {
	id: "1",
	id: "2"
};
console.log(meinObjekt.id); // Ausgabe: 2
<!--index_931c.html -->
```
In ECMAScript 5 wurde ein Syntax-Fehler gemeldet, wenn ein gleicher Name 
mehrmals in einem Objekt-Literal vorkam.

## Own Properie enumeration

ECMAScript 6 legt die Reihenfolge, in der Eigenschaften von Objekten aufgelistet 
werden fest. Diese Funktion erscheint auf den ersten Blick unwichtig. Sie sollten 
diese Funktion aber im Hinterkopf behalten. Es gibt Software, die eine bestimmte 
Reihenfolge in der Auflistung von Eigenschaften voraussetzt. ECMAScript 6 bietet 
eine Reihenfolge, auf die sich andere Programme verlassen können. 
Sehen Sie sich hierzu das nachfolgende Beispiel an.

```
let meinObjekt = {
	a: 1,
	z: 1,
	w: 1,
	10: 1,
	9: 1,
	1: 1,
	5: 1,
	b: 1,
};
console.log(Object.getOwnPropertyNames(meinObjekt)); 
// Ausgabe: Array(8) [ "1", "5", "9", "10", "a", "z", "w", "b" ]
<!--index_930.html -->
```

Die Sortierung erfolgt nach folgendenden Regeln:
1. Alle Zahlen in aufsteigender Reihenfolge.
2. Alle Strings in der Reihenfolge in der diese zum Objekt hinzugefügt wurden.
3. Alle Symbole in der Reihenfolge in der diese zum Objekt hinzugefügt wurden.

## Verbesserungen für Prototypen

### Einen Prototyp ändern

Mit ECMAScript 6 kann man Prototyp ändern 
`Object.setPrototypeOf();`

```
let mensch = { getGruss(){ return "Hallo";}};
let hund = { getGruss(){ return "Wauwau";}};
let frau = Object.create(mensch);
console.log(frau.getGruss()); // Ausgabe: Hallo
console.log(Object.getPrototypeOf(frau) === mensch); // Ausgabe: true
Object.setPrototypeOf(frau, hund);
console.log(frau.getGruss()); // Ausgabe: Hallo
console.log(Object.getPrototypeOf(frau) === hund); // Ausgabe: true
console.log(Object.getPrototypeOf(frau) === mensch); // Ausgabe: false
<!--index_929.html -->
```

### Leicherterer Zugriff mit super

Dieses Beispiel nutzt Vererbung. 
```
<!--index_928.html -->
```

Die Einführung von `super` vereinfacht dieses Beispiel

```
<!--index_928a.html -->
```

Aber: Syntax error bei verkürzter Sytnax:
https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/Methoden_Definitionen


```
<!--index_928b.html -->
```

`super` ist bei Mehrfachvererbung wirlich hilfreich. Alles funktioniert dann nicht mehr.

```
<!--index_928c.html -->
```

Mit super klappt das aber dann.

```
<!--index_928d.html -->
```

## Eine formale Methodendefinition


```
<!--index_927.html -->
```

`super.getGruss()` ist äquivalent zu `mensch.getGruss.call(this)`

Diese Funktion ist keine Methode.

```
function getGruss(){ 
return "Hi";
}
```


## Erfolgsmethode - Best Practice

## Alles noch einmal zusammengefasst

## Referenzen und externe Links


[^1]: https://de.wikipedia.org/w/index.php?title=Interpreter&oldid=182588640 (https://bit.ly/2GT9nQS)

todo https://github.com/woota/FE-training-examples/blob/master/es6/4.%20Arrow-Functions.md