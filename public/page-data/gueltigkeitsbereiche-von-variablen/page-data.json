{"componentChunkName":"component---src-templates-post-js","path":"/gueltigkeitsbereiche-von-variablen/","result":{"data":{"markdownRemark":{"html":"<p>JavaScript wird oft als Spielzeug abgewertet. Dabei besitzt die Skriptsprache neben ihrer Einfachheit bedeutende Sprachfunktionen. JavaScript wird von wichtigen Anwendungen verwendet. Darum ist es für jeden Web- und Mobil-Entwickler, sich mit JavaScript auszukennen!</p>\n<p>JavaScript wurde im Jahr 1995 entworfen und 1996 mit Netscape 2 veröffentlicht. Die Sprache ist somit recht etabliert. Ebenfalls im letzten Jahrhundert übergab Netscape JavaScript an <a href=\"https://www.ecma-international.org/\">Ecma International</a>, eine europäische Standardisierungsorganisation. Im selben Jahr wurde die erste Version des ECMAScript Standards publiziert. Dieser hält sich seither stabil. Hier im Buch spielen die Neuerungen in der sechsten Edition  – ES2015 oder ES6 – die Hauptrolle, welche im Juni 2015 veröffentlicht wurde.</p>\n<p>Neue Browserversionen decken einen großen Teil der Funktionen in ES2015 ab. Leider aber nicht alle. Eine Website zum Verbreitungsstand einzelner Features ist <a href=\"https://caniuse.com/\">caniuse.com</a>   .  </p>\n<blockquote>\n<p>Sie nutzen eine Funktion, die nicht vollständig von Browsern unterstützt wird? Dafür gibt es Transpiler. Dies ist ein Thema für ein separates Buch. </p>\n</blockquote>\n<p>Ich erkläre alles in kleinen Schritten nacheinander. Ich hoffe, dass Ihnen meine Art zu schreiben gefällt. Ich persönlich hätte mir ein solches Buch zum Start mit ES6 gewünscht.</p>\n<p>Ich gehe davon aus, dass Sie HTML kennen und über JavaScript Grundlagen verfügen. Alle Beispiele finden Sie auf <a href=\"https://github.com/astridx/es6_beispieldateien_zum_Buch\">Github</a>.</p>\n<p>In diesem Teil geht es um Gültigkeitsbereiche von Variablen, um <code class=\"language-text\">let</code>, <code class=\"language-text\">const</code> und <code class=\"language-text\">var</code>.</p>\n<h2 id=\"motivation\"><a href=\"#motivation\" aria-label=\"motivation permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Motivation</h2>\n<p>Die Variablendeklarationen mithilfe von <code class=\"language-text\">var</code> in JavaScript geschieht bevor Programmcode ausgeführt wird. So ist das Deklarieren an einer beliebigen Stelle im Programm das gleiche, als würde sie am Anfang eingeführt. Eine Variable ist nutzbar, bevor sie im Programmcode deklariert wurde! Dieser Umstand wird <code class=\"language-text\">hoisting</code> genannt und ist meiner Meinung nach nicht intuitiv und verwirrend. </p>\n<p>ES6 bietet Strukturen, die den Überblick über Gültigkeitsbereiche vereinfachen. Diese stelle ich im Folgenden vor. Nebenbei erläutere ich Best Praxis Konzepte. </p>\n<h2 id=\"var---deklaration-und-hoisting\"><a href=\"#var---deklaration-und-hoisting\" aria-label=\"var   deklaration und hoisting permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>var - Deklaration und Hoisting</h2>\n<p>Die Deklaration einer Variablen geschieht </p>\n<ul>\n<li>m globalen Kontext, wenn sie außerhalb oder am Anfang einer Funktion deklariert wurde oder </li>\n<li>ganz am Anfang einer Funktion.  </li>\n</ul>\n<p>Konkret bedeutet das, dass das Deklarieren einer Variable an einer beliebigen Stelle im Programmcode das Gleiche ist, als würde sie am Anfang deklariert. Sie ist nutzbar, bevor sie im Code eingeführt wurde. Dies nennt man <code class=\"language-text\">hoisting</code>.  </p>\n<h3 id=\"exkurs-der-unterschied-zwischen-instanziieren-deklarieren-und-initialisieren\"><a href=\"#exkurs-der-unterschied-zwischen-instanziieren-deklarieren-und-initialisieren\" aria-label=\"exkurs der unterschied zwischen instanziieren deklarieren und initialisieren permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Exkurs: Der Unterschied zwischen instanziieren, deklarieren und initialisieren</h3>\n<h4 id=\"variable-instanziieren\"><a href=\"#variable-instanziieren\" aria-label=\"variable instanziieren permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Variable instanziieren</h4>\n<p>Der Begriff Instanziieren meint das Erzeugen eines neuen Objekts, einer Instanz, aus einer Klasse.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Objekt o = new Objekt();\n// o ist Instanz der Klasse Objekt</code></pre></div>\n<h4 id=\"variable-deklarieren\"><a href=\"#variable-deklarieren\" aria-label=\"variable deklarieren permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Variable deklarieren</h4>\n<p>Stellen Sie sich unter „deklarieren einer Variablen“ das erste <em>Erwähnen der Variablen</em> vor. So weiß der Compiler, dass es sie gibt, und ihm ist es möglich, sie anzusprechen. Der Wert selbst wird bei der Deklaration nicht festgelegt.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">int var;\n// var als Variable des Typs int deklariert</code></pre></div>\n<h4 id=\"variable-initialisieren\"><a href=\"#variable-initialisieren\" aria-label=\"variable initialisieren permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Variable initialisieren</h4>\n<p>Eine Initialisierung ist das erste Zuweisen eines Wertes zu einer Variablen. Hier zu ist es erforderlich, dass der Speicher allokiert ist.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var = 0;\n// var mit Wert 0 initialisiert</code></pre></div>\n<p>Sehen wir uns <code class=\"language-text\">hoisting</code> an einem Beispiel genauer an.</p>\n<h3 id=\"beispiele\"><a href=\"#beispiele\" aria-label=\"beispiele permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Beispiele</h3>\n<h4 id=\"beispiel-1\"><a href=\"#beispiel-1\" aria-label=\"beispiel 1 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Beispiel 1</h4>\n<p>Sehen Sie sich die nachfolgende Funktion kurz an. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    if (false) {\n        var value = &quot;Prima&quot;;\n        return value;\n    } else {\n        return value; // gibt &quot;undefined&quot; oder &quot;&quot; aus, abhängig vom Browser.\n    }\n}\n&lt;!--index_999a.html--&gt;</code></pre></div>\n<p>Wenn Sie nicht vertraut mit JavaScript sind, erwarten Sie, dass die Variable <code class=\"language-text\">value</code> nur erstellt wird, wenn die Bedingung in der <code class=\"language-text\">if</code>-Anweisung <code class=\"language-text\">true</code> ist. In der Realität ist es so, dass die Variable in jedem Fall kreiert wird.</p>\n<p>Im Hintergrund verändert JavaScipt den Programmcode. Der <a href=\"https://de.wikipedia.org/w/index.php?title=Interpreter&#x26;oldid=182588640\">Interpreter</a> macht daraus konkret den folgenden Aufruf. Im Code habe ich die wesentliche Zeile für Sie mit einem Stern markiert.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n*    var value;\n     if (false) {\n         var value = &quot;Prima&quot;;\n         return value;\n     } else {\n         return value; // gibt &quot;undefined&quot; oder &quot;&quot; aus, abhängig vom Browser.\n     }\n     // die Variable value existiert auch hier\n }\n&lt;!--index_999a.html aus Sicht des Interpeters--&gt;</code></pre></div>\n<p>Die Deklaration der Variablen <code class=\"language-text\">value</code> wird an den Anfang der Funktion verschoben. Die Initialisierung geschieht im gleichen Gültigkeitsbereich. Dadurch ist es möglich im <code class=\"language-text\">else</code>-Block auf die Variablen <code class=\"language-text\">value</code> zuzugreifen. Da die <code class=\"language-text\">value</code> im <code class=\"language-text\">else</code>-Block mit keinem Wert belegt ist, ist die Ausgabe bei einem Zugriff <code class=\"language-text\">undefined</code> anstelle von <code class=\"language-text\">ReferenceError: value is not defined</code>, wie im nachfolgenden Beispiel. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n     if (false) {\n         var value = &quot;Prima&quot;;\n         return value;\n     } else {\n*        return myvalue; // gibt &quot;ReferenceError: myvalue is not defined&quot; aus\n     }\n }\n&lt;!--index_999c.html --&gt;</code></pre></div>\n<p><code class=\"language-text\">Hoisting</code> führt oft zu Missverständnissen. Für viele Entwickler ist es befremdend, dass eine Variable nicht an der Stelle erstellt wird, an der sie im Programmcode steht. Deshalb wurde mit ECMAScript 6 die Möglichkeit eingeführt, Variablen im Gültigkeitsbereich des lokalen Blocks zu deklarieren.</p>\n<h2 id=\"gultigkeitsbereich-scope-im-block\"><a href=\"#gultigkeitsbereich-scope-im-block\" aria-label=\"gultigkeitsbereich scope im block permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gültigkeitsbereich (Scope) im Block</h2>\n<p>In vielen Programmiersprachen gibt es den Block Scope – alle Variablen, die innerhalb eines Blocks deklariert werden, gelten nur in ihm. Diese nennt man lokale Variablen.</p>\n<p>Was genau ist ein Block? Ein Block ist entweder </p>\n<ul>\n<li>der Bereich innerhalb einer Funktion oder</li>\n<li>ein Bereich der mit geschweiften Klammern - <code class=\"language-text\">{</code> und <code class=\"language-text\">}</code> - umgeben ist. </li>\n</ul>\n<p>Variablen, die mit <code class=\"language-text\">let</code> oder <code class=\"language-text\">const</code> angelegt werden, gelten ausschließlich innerhalb ihres Blocks. Es verhindert viele schwer aufzudeckende Fehler und ist meiner Meinung nach intuitiv. </p>\n<h3 id=\"block-scope-mit-let\"><a href=\"#block-scope-mit-let\" aria-label=\"block scope mit let permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Block Scope mit let</h3>\n<p>Mit ECMAScript 6 wurde <code class=\"language-text\">let</code> eingeführt. Eine mit <code class=\"language-text\">let</code> deklarierte Variable hat einen eingeschränkten Gültigkeitsbereich. Sie ist einzig und allein innerhalb des Blocks gültig, in dem sie deklariert wurde.\nDie Deklaration einer Variablen mit <code class=\"language-text\">let</code> geschieht auf die gleiche Art wie die Deklaration einer Variablen mit <code class=\"language-text\">var</code>.  </p>\n<p>Was wäre, wenn die Variable im vorherigen Beispiel anstelle von <code class=\"language-text\">var</code> mit <code class=\"language-text\">let</code> deklariert worden wäre? Genau dies zeigt Ihnen der nachfolgende Code.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n     if (true) {\n         let value = &quot;Prima&quot;;\n     } else {\n*        return value; // Würde &quot;ReferenceError: value is not defined&quot; ausgeben.\n     }\n*    return value; // Gibt &quot;ReferenceError: value is not defined&quot; aus.\n}\n&lt;!--index_998d.html --&gt;</code></pre></div>\n<p>Haben Sie den Programmcode ausprobiert oder gedanklich nachvollzogen? Dann stimmen Sie sicher mit mir überein, das die Ausgabe der Datei <code class=\"language-text\">998d.html</code> intuitiver ist als die das Ergebnis von <code class=\"language-text\">999a.html</code>. </p>\n<p>Weil wir die Variable <code class=\"language-text\">value</code> mit <code class=\"language-text\">let</code> deklariert haben, wird die Deklaration nicht im Hintergrund vom Interpreter an den Anfang der Funktion verschoben. Ein Zugriff auf sie ist außerhalb der <code class=\"language-text\">if</code>-Anweisung nicht gegeben. Da <code class=\"language-text\">value</code> nur deklariert wird, wenn die Bedingung der <code class=\"language-text\">if</code>-Anweisung erfüllt ist, ist es nicht möglich, im <code class=\"language-text\">else</code>-Block auf sie zuzugreifen. </p>\n<p>Das nächste Beispiel zeigt Ihnen, dass die Deklaration der Variablen <code class=\"language-text\">value</code> weiterhin am Anfang des Blocks geschieht, in dem diese gültig ist. Es ist aber erst möglich, auf sie zuzugreifen, nachdem sie deklariert wurde. Einen Unterschied gibt es: Die Fehlermeldung innerhalb des Blocks, indem die Variable deklariert wird, ist eine andere. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    if (true) {\n        return value; // gibt &quot;ReferenceError: can&#39;t access lexical \n                      //declaration `value&#39; before initialization&quot; ausgeben.\n        let value = &quot;Prima&quot;;\n    } else {\n        return value; // würde &quot;ReferenceError: value is not defined&quot; ausgeben.\n    }\n}\n&lt;!--index_998e.html --&gt;</code></pre></div>\n<h3 id=\"keine-mehrfachverwendung\"><a href=\"#keine-mehrfachverwendung\" aria-label=\"keine mehrfachverwendung permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Keine Mehrfachverwendung</h3>\n<p>Die Mehrfachverwendung einer mit <code class=\"language-text\">let</code> deklarierten Variablen innerhalb eines Blocks ist nicht möglich. Falls Sie dies versehentlich doch versuchen, wird der JavaScript Interpreter Ihnen den Fehler <code class=\"language-text\">SyntaxError: redeclaration of let value</code> melden.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n     var value = &quot;Prima&quot;;\n*    let value = &quot;Prima&quot;;  // SyntaxError: redeclaration of let value\n }\n&lt;!--index_997.html --&gt;</code></pre></div>\n<p>Im vorhergehenden Beispiel wurde die Variable <code class=\"language-text\">value</code> zweimal deklariert. Beim ersten Mal mit <code class=\"language-text\">var</code> und beim zweiten Mal mit <code class=\"language-text\">let</code>. Weil diese beiden Variablendeklarationen im selben Gültigkeitsbereich liegen, tritt ein Fehler auf. </p>\n<p>Im Umkehrschluss ist es möglich, eine Variable mit dem gleichen Namen in einem untergeordneten oder übergeordneten Gültigkeitsbereich zu deklarieren.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var value = &quot;Prima&quot;;\n    if (true) {\n        let value = &quot;Prima&quot;;\n    }   \n    return true;\n}\n&lt;!--index_997d.html --&gt;</code></pre></div>\n<p>Im Beispiel der Datei <code class=\"language-text\">997d.html</code> tritt kein Fehler auf. Die Variable mit dem Namen <code class=\"language-text\">value</code> wird in der <code class=\"language-text\">if</code>-Anweisung neu deklariert. Die Deklaration passiert genau an der Stelle, an der der Programmierer sie in den Programmcode einfügt. Sie wird nicht, wie im Falle von <code class=\"language-text\">var</code>, vom Interpreter an den Beginn des umgebenden Blocks gesetzt. </p>\n<h3 id=\"block-scope-mit-const\"><a href=\"#block-scope-mit-const\" aria-label=\"block scope mit const permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Block Scope mit const</h3>\n<p>Die Deklaration einer Variablen mit dem Schlüsselwort <code class=\"language-text\">const</code> erstellt eine Konstante. Der Gültigkeitsbereich einer mit <code class=\"language-text\">const</code> deklarierten Variablen ist, genau wie bei einer mit <code class=\"language-text\">let</code> deklarierten Variable, auf den lokalen Block begrenzt. Der Wert einer Konstanten ist bei der Deklaration anzugeben. Es ist nicht möglich, diesen später zu setzten.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    const value1 = &quot;Prima&quot;;\n    const value2; // SyntaxError: missing = in const declaration\n}\n&lt;!--index_996.html --&gt;</code></pre></div>\n<p>Im vorherigen Beispiel wird die Variable <code class=\"language-text\">value1</code> korrekt deklariert und initialisiert. Die Deklaration von <code class=\"language-text\">value2</code> ist nicht möglich. Es wird ein Fehler angezeigt, weil <code class=\"language-text\">value2</code> beim Anlegen nicht initialisiert wurde.</p>\n<h4 id=\"konstante-versus-variablendeklaration-mit-let\"><a href=\"#konstante-versus-variablendeklaration-mit-let\" aria-label=\"konstante versus variablendeklaration mit let permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Konstante versus Variablendeklaration mit let</h4>\n<p>Genau wie im Falle von <code class=\"language-text\">let</code> ist eine mit <code class=\"language-text\">const</code> deklarierte Variable ausschließlich innerhalb eines Blocks gültig.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    if (true) {\n        const value = &quot;Prima&quot;;\n    }   \n    return value; //ReferenceError: value is not defined\n}\n&lt;!--index_995.html --&gt;</code></pre></div>\n<p>Eine weitere Gemeinsamkeit von <code class=\"language-text\">let</code> und <code class=\"language-text\">const</code> ist die nicht mögliche\nMehrfachverwendung.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var value1 = &quot;Prima&quot;;\n    let value2 = &quot;Super&quot;;\n    const value1 = &quot;Prima&quot;; // SyntaxError: redeclaration of var value1\n    const value2 = &quot;Super&quot;; // SyntaxError: redeclaration of var value2\n    return true;\n}\n&lt;!--index_994.html --&gt;</code></pre></div>\n<p>Abgesehen von diesen Gemeinsamkeiten gibt es einen bedeutenden Unterschied. Anders als bei einer mit <code class=\"language-text\">let</code> deklarierten Variablen ist es nicht möglich, den Wert einer Konstanten im Nachhinein zu ändern.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    let value1 = &quot;Prima&quot;;\n    const value2 = &quot;Super&quot;;\n    value1 = &quot;Toll&quot;;\n    value2 = &quot;Schön&quot;; // TypeError: invalid assignment to const `value2&#39;\n    return true;\n}\n&lt;!--index_993.html --&gt;</code></pre></div>\n<h4 id=\"objektdeklaration-mit-const\"><a href=\"#objektdeklaration-mit-const\" aria-label=\"objektdeklaration mit const permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Objektdeklaration mit const</h4>\n<p>Erklärungsbedürftig ist die Behandlung von Konstanten in JavaScript, wenn ein Objekt als Konstante deklariert wurde. In diesem Falle ist nur das Objekt selbst konstant. Die Eigenschaften des Objektes sind veränderbar. Theoretisch hört sich dies nicht schlüssig an. Sehen Sie sich das nächste Beispiel an, dann wird es klar.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    const stadt = {\n        name: &quot;Koblenz&quot;\n    }\n    stadt.name = &quot;Bonn&quot;; // Mögliche Neuzuweisung\n    stadt.fluss = &quot;Rhein&quot;; // Mögliche Neuzuweisung\n    \n    const stadt = { // SyntaxError: redeclaration of const stadt\n        name: &quot;Bonn&quot; \n    } \n    return true;\n}\n&lt;!--index_992.html --&gt;</code></pre></div>\n<p>Im vorhergehenden Beispiel wurde eine Konstante mit dem Namen Stadt erstellt. Diese ist nicht veränderbar. Bemerkenswert ist, dass die Eigenschaften <code class=\"language-text\">name</code> und <code class=\"language-text\">fluss</code> änderbar sind.</p>\n<h3 id=\"die-vorubergehend-tote-zone\"><a href=\"#die-vorubergehend-tote-zone\" aria-label=\"die vorubergehend tote zone permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Die vorübergehend tote Zone</h3>\n<p>Variablen, die mit <code class=\"language-text\">let</code> oder <code class=\"language-text\">const</code> angelegt werden, gelten nur innerhalb ihres Blocks. Dies führt in JavaScript zu einem Zustand, der sich gefährlich anhört: <em>Der vorübergehend toten Zone</em>. Der englische Ausdruck dafür ist <em>Temporal Dead Zone (TDZ)</em>. </p>\n<p>Die <em>vorübergehend toten Zone</em> ist der Bereich innerhalb eines Blocks, der vor einer Variablendeklaration liegt. Vorausgesetzt die Variable wird mit <code class=\"language-text\">let</code> oder <code class=\"language-text\">const</code> deklariert. </p>\n<p>In der <em>vorübergehend toten Zone</em> tritt beim Zugriff auf eine später deklarierte Variable, ein Fehler auf. Verhängnisvoll ist, dass dieser Fehler ebenfalls auftritt, wenn eine vermeintlich sichere Methode wie <code class=\"language-text\">typeof</code> verwendet wird.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    console.log(typeof value1); // Ausgabe: undefined\n    console.log(typeof value2); // ReferenceError: can&#39;t access lexical declaration\n                                // `value2&#39; before initialization\n    let value2 = &quot;Prima&quot;; \n\n    return true;\n}\n&lt;!--index_991.html --&gt;</code></pre></div>\n<p>Im vorhergehenden Beispiel wird auf die Variablen <code class=\"language-text\">value1</code> und <code class=\"language-text\">value2</code> mithilfe von <code class=\"language-text\">typeof</code> zugegriffen. Im Falle von <code class=\"language-text\">value1</code> ist dies kein Problem. Bei <code class=\"language-text\">value2</code> tritt hingegen ein Fehler auf, weil <code class=\"language-text\">value2</code> im gleichen Gültigkeitsbereich später erneut mit <code class=\"language-text\">let</code> deklariert wird. </p>\n<p>Die gleiche Deklaration in einem anderen Gültigkeitsbereich wäre kein Problem, wie Beispiel <code class=\"language-text\">index_991c.html</code> zeigt.  </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    console.log(typeof value1); // Ausgabe: undefined\n    console.log(typeof value2); // Ausgabe: undefined\n\n    if (true) {\n        let value2 = &quot;Prima&quot;;\n    }\n        \n    return true;\n}\n&lt;!--index_991c.html --&gt;</code></pre></div>\n<blockquote>\n<p>Die Bezeichnung <em>Temporal Dead Zone (TDZ)</em> sucht man in der Spezifikation <em>ECMAScript 6</em> vergeblich. Der Begriff wird aber häufig zur Erklärung eingesetzt. Die TDZ entsteht, weil der JavaScript-Interpreter sich einen Block schon beim Einlesen vollständig ansieht. Wenn er auf mit <code class=\"language-text\">var</code> deklarierte Variable trifft, dann setzt er die Deklaration an den Beginn der Funktion oder in den globalen Gültigkeitsbereich. Findet der Interpreter eine mit <code class=\"language-text\">let</code> oder <code class=\"language-text\">const</code> deklarierte Variable, dann setzt er diese in die TDZ - solange, bis die eigentliche Deklaration vonstattengeht. </p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n     console.log(typeof value); // Ausgabe: undefined\n*    if (true) {\n*        let value = &quot;Prima&quot;;\n*        console.log(typeof value); // Ausgabe: String\n*    }\n     console.log(typeof value); // Ausgabe: undefined\n     return true;\n }\n&lt;!--index_991a.html --&gt;</code></pre></div>\n<p>Die Variable <code class=\"language-text\">value</code> ist beim Aufruf des Befehls <code class=\"language-text\">console.log(typeof value)</code> nicht in der TDZ. Das bedeutet konkret: Die Variable ist zwar <code class=\"language-text\">undefinded</code>  aber frei.</p>\n<blockquote>\n<p>Die Beispiele zur TDZ verwenden hier ausschließlich mithilfe von <code class=\"language-text\">let</code> deklarierte Variablen. Das Gleiche gilt analog für Variablen, die mit <code class=\"language-text\">const</code> erstellt wurden.</p>\n</blockquote>\n<h2 id=\"gultigkeitsbereich-scope-in-schleifen\"><a href=\"#gultigkeitsbereich-scope-in-schleifen\" aria-label=\"gultigkeitsbereich scope in schleifen permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gültigkeitsbereich (Scope) in Schleifen</h2>\n<p>Eine weitere Besonderheit von JavaScript ist der Gültigkeitsbereich innerhalb von Schleifen. Beim Durchlaufen von Schleifen bringt es viele Vorteile, wenn die Gültigkeitsbereiche der Variablen übersichtlich und getrennt sind. In einer Schleife wird häufig eine Variable als Zähler verwendet. Das nächste Beispiel zeigt Ihnen, dass der Gültigkeitsbereich einer solchen Zählervariablen alles andere als übersichtlich und getrennt ist, wenn diese Variable mit <code class=\"language-text\">var</code> deklariert wird. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    for (var i = 0; i &lt; 5; i++) {\n        // tue etwas ...\n    }\n    console.log(i); // Ausgabe: 5\n    return true;\n}\n&lt;!--index_990.html --&gt;</code></pre></div>\n<p>Nachdem der Schleifendurchlauf abgeschlossen ist und der Block verlassen wurde, ist die Variable <code class=\"language-text\">i</code> weiterhin gültig. Der letzte Wert der Variablen wird mittels <code class=\"language-text\">console.log(i)</code> ausgegeben. Dies ist ein Verhalten, das nicht erwünscht ist. Die Zählervariable <code class=\"language-text\">i</code> wird in der Regel nur lokal in der Schleife benötigt und es wäre wünschenswert, wenn sie nur hier ihren Gültigkeitsbereich hätte. Aber, Sie wissen es schon: Bei der Verwendung von <code class=\"language-text\">var</code> zur Deklaration wird diese Deklaration aufgrund von <a href=\"https://de.wikipedia.org/w/index.php?title=Hoisting&#x26;oldid=166784898\">Hosting</a> an den Anfang der Funktion verschoben und ist somit innerhalb des vollständigen Blocks gültig.</p>\n<p>Das nächste Beispiel nutzt anstelle von <code class=\"language-text\">var</code> eine mit <code class=\"language-text\">let</code> deklarierte Variable als Zähler. Das Ergebnis ist das erwartete Verhalten.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    for (let i = 0; i &lt; 5; i++) {\n        console.log(i); // Ausgabe: 0 1 2 3 4\n    }\n    console.log(i); // ReferenceError: i is not defined\n    return true;\n}\n&lt;!--index_989.html --&gt;</code></pre></div>\n<p>Das Beispiel der Datei <code class=\"language-text\">index_989.html</code> demonstriert das gewünschte Verhalten. Die Variable <code class=\"language-text\">i</code> existiert nur innerhalb der Schleife. Nachdem die Schleife abgearbeitet ist, ist es nicht mehr möglich auf <code class=\"language-text\">i</code> zuzugreife. Die Variable <code class=\"language-text\">i</code> stiftet so keine Verwirrung mehr außerhalb der Schleife.</p>\n<h3 id=\"funktionen-in-schleifen\"><a href=\"#funktionen-in-schleifen\" aria-label=\"funktionen in schleifen permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Funktionen in Schleifen</h3>\n<p>Hosting und das Verhalten von <code class=\"language-text\">var</code> bewirken, das dass Arbeiten mit Funktionen in Schleifen unvorhersehbar ist. Das nächste Beispiel zeigt Ihnen, auf was ich genau abziele.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    for (var i = 0; i &lt; 5; i++) {\n        funktionen.push(function() {\n            console.log(i);\n        });\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); // Ausgabe: Fünfmal die Zahl &quot;5&quot;\n    });\n    return true;\n}\n&lt;!--index_988.html --&gt;</code></pre></div>\n<p>Haben Sie die Ausgabe <code class=\"language-text\">0 1 2 3 4</code> erwartet? Anstelle davon wurde <code class=\"language-text\">5 5 5 5 5</code> ausgegeben. Der Grund hierfür ist, dass dieselbe Variable <code class=\"language-text\">i</code> über alle Iterationen der Schleife hinweg geteilt wird. Aufgrund von Hoisting wurde die Variable <code class=\"language-text\">i</code> außerhalb der Schleife deklariert. Alle Funktionen, die in der Schleife erstellt wurden, halten eine Referenz auf dieselbe Variable <code class=\"language-text\">i</code>. Diese Variable <code class=\"language-text\">i</code> hat den Wert <code class=\"language-text\">5</code>, wenn alle Schleifendurchläufe beendet sind. Wenn <code class=\"language-text\">console.log(i)</code> aufgrund von </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">funktionen.forEach(function(funktion){\n    funktion(); \n});</code></pre></div>\n<p>fünfmal ausgeführt wird, wird der Wert <code class=\"language-text\">5</code> fünfmal ausgegeben.  </p>\n<p>Eine Lösung für dieses Problem ist <a href=\"https://wiki.selfhtml.org/index.php?title=IIFE&#x26;oldid=59916\">IIFE</a>. <em>IIFE</em> steht für <em>Immediately-invoked Function Expression</em>. Mit anderen Worte bedeutet dies: ein sofort ausgeführter Funktionsausdruck. Das hört sich kompliziert an und das ist es meiner Meinung nach auch. Ich habe <em>IIFE</em> hier der Vollständigkeit halber aufgenommen. Im nächsten Kapitel finden Sie eine einfachere Lösung, seit ECMAScript 6.  </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    for (var i = 0; i &lt; 5; i++) {\n        funktionen.push((function(value) {\n            return function (){\n                console.log(value);\n            }\n        }(i)));\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); // Ausgabe: 0 1 2 3 4 \n    });\n    return true;\n}\n&lt;!--index_987.html --&gt;</code></pre></div>\n<p>Das Beispiel in der Datei <code class=\"language-text\">index_987.html</code> verwendet IIFE. Das Grundgerüst\neiner IIFE finden Sie im nächsten Programmcodebeispiel.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(function (foo) {\n    //...\n})(foo);</code></pre></div>\n<p>Dieses Grundgerüst sieht soweit recht unkompliziert aus. Beispiel <code class=\"language-text\">index_987.html</code> wirkt hingegen kompliziert. Deshalb sehen wir uns die relevanten Teile genauer an.  </p>\n<p>Die Variable <code class=\"language-text\">i</code> wird im Beispiel <code class=\"language-text\">index_987.html</code> an die IIFE übergeben. Im nachfolgenden Programmcodebeispiel habe ich die IIFE des Beispiel <code class=\"language-text\">index_987.html</code> für sich alleine eingefügt.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">...\n...(function(value) {\n       return function (){\n           console.log(value);\n       }\n   }(i))...\n...</code></pre></div>\n<p>Die IIFE speichert die Variable <code class=\"language-text\">i</code> in einer eigenen Kopie. In unserem Beispiel erhält diese Kopie den Namen <code class=\"language-text\">value</code>. Die Kopie der Variablen <code class=\"language-text\">i</code>, ergo <code class=\"language-text\">value</code> , wird in der Funktion verwendet. </p>\n<p>Dies führt dazu, dass die Ausgabe der Schleife eher der Erwartung eines Programmierers entspricht, als die Ausgabe der Schleife in Beispiel <code class=\"language-text\">index_988.html</code>. </p>\n<p>Wie schon erwähnt bietet ECMAScript 6 glücklicherweise eine einfacherere Möglichkeit, diese Ausgabe zu erreichen. Diese Möglichkeit sehen wir uns im nächsten Kapitel an.</p>\n<h3 id=\"let-in-schleifen\"><a href=\"#let-in-schleifen\" aria-label=\"let in schleifen permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>let in Schleifen</h3>\n<p>Eine mit <code class=\"language-text\">let</code> deklarierte Variable <code class=\"language-text\">i</code> in der Schleifenbedingung vereinfacht die Arbeit mit der Schleife ungemein. Bei jedem Schleifendurchlauf wird aufgrund von <code class=\"language-text\">let</code> eine neue Variable <code class=\"language-text\">i</code> erstellt und mit dem aktuellen Wert initialisiert. Das nächste Beispiel zeigt Ihnen, dass man so vollständig auf das komplizierte IIFE Konstrukt verzichten kann.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    for (let i = 0; i &lt; 5; i++) {\n        funktionen.push(function() {\n            console.log(i);\n        });\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); // Ausgabe: 0 1 2 3 4\n    });\n    return true;\n}\nwindow.addEventListener(&quot;load&quot;, function () {\nconsole.log(getValue());\n});\n&lt;!--index_986.html --&gt;</code></pre></div>\n<p>Das Beispiel der Datei <code class=\"language-text\">index_986.html</code> errechnet genau das, was das Beispiel\nder Datei <code class=\"language-text\">index_987.html</code> errechnete - allerdings auf eine wesentlich\nkomfortable Art.</p>\n<p>Überzeugen Sie sich mit dem Beispiel in der Datei <code class=\"language-text\">index_985.html</code> davon, dass das was ich für eine <code class=\"language-text\">forEach</code> Schleife beschrieben habe, gleichzeitig für <code class=\"language-text\">for-in</code> und <code class=\"language-text\">for-of</code> Schleifen gilt.</p>\n<p><code class=\"language-text\">for-of</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    var names = [&#39;Astrid&#39;, &#39;Nina&#39;, &#39;Elmar&#39;];\n    \n    for (let name of names) {\n        funktionen.push(function() {\n            console.log(name);\n        });\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); \n    });\n    return true;\n}\n&lt;!--index_985.html --&gt;</code></pre></div>\n<p><code class=\"language-text\">for-in</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    var object = {\n        1 : &quot;a&quot;,\n        2 : &quot;b&quot;,\n        3 : &quot;c&quot;\n    };\n    \n    for (let key in object) {\n        funktionen.push(function() {\n            console.log(key);\n        });\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); \n    });\n    return true;\n}\n&lt;!--index_984.html --&gt;</code></pre></div>\n<p>In den Beispielen zur <code class=\"language-text\">for-in</code>-Schleife und zur <code class=\"language-text\">for-of</code>-Schleife wird bei jedem Schleifendurchlauf eine Kopie von <code class=\"language-text\">key</code> angelegt. Dies geschieht, weil <code class=\"language-text\">key</code> mit <code class=\"language-text\">let</code> deklariert wurde. Für die Ausgabe wird immer diese Kopier verwendet. Deshalb ist die Ausgabe im ersten Fall <code class=\"language-text\">Astrid Nina Elmar</code> und im zweiten Fall <code class=\"language-text\">1 2 3</code>. Wenn <code class=\"language-text\">key</code> mit <code class=\"language-text\">var</code> deklariert worden wäre, würde im ersten Fall dreimal <code class=\"language-text\">Elmar</code> ausgegeben und im zweiten Fall dreimal <code class=\"language-text\">3</code>.</p>\n<h3 id=\"const-in-schleifen\"><a href=\"#const-in-schleifen\" aria-label=\"const in schleifen permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>const in Schleifen</h3>\n<p>Die ECMAScript 6 Spezifikation verbietet die Verwendung von Konstanten als Schleifenbedingung nicht. Aber: Es empfiehlt sich, sich die Zusammenhänge vorher genau anzusehen, wenn man eine Konstante als Schleifenbedingung verwendet. Die <code class=\"language-text\">for-in</code>-Schleife und die <code class=\"language-text\">for-of</code>-Schleife wenden eine Konstante anders an, als eine normale <code class=\"language-text\">for</code>-Schleife es macht.  </p>\n<p>Sehen wir uns die Zusammenhänge im Folgenden an.</p>\n<h4 id=\"for-schleife\"><a href=\"#for-schleife\" aria-label=\"for schleife permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>For-Schleife</h4>\n<p>In einer For-Schleife ist es zwar erlaubt die Schleifenbedingung als Konstante zu initialisieren. Es ist aber in den meisten Fällen nicht sinnvoll. Denn: Bei der Ausführung der Schleife wird ein Fehler gemeldet, wenn der Wert der Konstanten geändert wird.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    for (const i = 0; i &lt; 5; i++) {\n        funktionen.push(function() {\n            console.log(i);\n        });\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); // Ausgabe: TypeError: invalid assignment to const i\n    });\n    return true;\n}\n&lt;!--index_983.html --&gt;</code></pre></div>\n<p>Im vorhergehenden Beispiel wird die Variable <code class=\"language-text\">i</code> als Konstante deklariert. Der erste Schleifendurchlauf ist erfolgreich. Bei diesem ist der Wert von <code class=\"language-text\">i</code> gleich <code class=\"language-text\">0</code>. Beim nächsten Schleifendurchlauf tritt ein Fehler auf, wenn <code class=\"language-text\">i++</code> aufgerufen wird.\nDie Fehlermeldung lautet im Browser Firefox <code class=\"language-text\">TypeError: invalid assignment to const i</code>. </p>\n<p>Der nächste Programmcode zeigt ein konstruiertes Beispiel. Im Beispiel wird in der Schleifenbedingung eine Konstante verwendet. Es tritt aber kein Fehler auf, weil die Schleife mit <code class=\"language-text\">break</code> abbricht, bevor <code class=\"language-text\">i++</code> an der Reihe ist.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    for (const i = 0; i &lt; 5;) {\n        funktionen.push(function() {\n            console.log(i);\n        });\n        break;\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); // Ausgabe: 0\n    });\n    return true;\n}\n&lt;!--index_983c.html --&gt;</code></pre></div>\n<h4 id=\"for-in-schleife-und-for-of-schleife\"><a href=\"#for-in-schleife-und-for-of-schleife\" aria-label=\"for in schleife und for of schleife permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>For-in-Schleife und For-of-Schleife</h4>\n<p>In einer <code class=\"language-text\">for-in</code>-Schleife oder einer <code class=\"language-text\">for-of</code>-Schleife ist es möglich, mit einer Konstanten zu arbeiten. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    var names = [&#39;Astrid&#39;, &#39;Nina&#39;, &#39;Elmar&#39;];\n    \n    for (const name of names) {\n        funktionen.push(function() {\n            console.log(name);\n        });\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); // Ausgabe: Astrid Nina Elmar\n    });\n    return true;\n}\n&lt;!--index_983a.html --&gt;</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    var object = {\n        1 : &quot;a&quot;,\n        2 : &quot;b&quot;,\n        3 : &quot;c&quot;\n    };\n    \n    for (const key in object) {\n        funktionen.push(function() {\n            console.log(key);\n        });\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); // Ausgabe: 1 2 3\n    });\n    return true;\n}\n&lt;!--index_983b.html --&gt;</code></pre></div>\n<p>Warum in einer <code class=\"language-text\">for-in</code>-Schleife oder einer <code class=\"language-text\">for-of</code>-Schleife eine Konstante als Schleifenbedingung keinen Fehler erzeugt ist bei genauem Hinsehen offensichtlich. Beim Schleifendurchlauf wird der Konstanten nie ein anderer Wert zugeordnet. Es wird vielmehr die Zuordnung zur Konstanten <code class=\"language-text\">name</code> oder <code class=\"language-text\">key</code> geändert.</p>\n<h2 id=\"globaler-gultigkeitsbereich-scope\"><a href=\"#globaler-gultigkeitsbereich-scope\" aria-label=\"globaler gultigkeitsbereich scope permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Globaler Gültigkeitsbereich (Scope)</h2>\n<p>Im globalen Gültigkeitsbereich gibt es Unterschiede zwischen <code class=\"language-text\">var</code> und den ECMAScript 6- Neulingen <code class=\"language-text\">let</code> beziehungsweise <code class=\"language-text\">const</code>.  </p>\n<p>Zum einen überschreibt eine im globalen Gültigkeitsbereich mit <code class=\"language-text\">var</code> deklarierte Variable die gleichnamige Eigenschaft im <code class=\"language-text\">window</code> Objekt. Das nachfolgende Beispiel verdeutlich das beschriebene. So hat JavaScript in der Vergangenheit immer gearbeitet. Das ist meiner Meinung nach eine gefährliche Fehlerquelle.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(window.RegExp); // Ausgabe: function RegExp()\nvar RegExp = &quot;Neuer Wert für RegExp&quot;;\nconsole.log(window.RegExp); // Ausgabe: &quot;Neuer Wert für RegExp&quot;\n&lt;!--index_982.html --&gt;</code></pre></div>\n<p>Wenn anstelle von <code class=\"language-text\">var</code> eine Variable im globalen Gültigkeitsbereich mit <code class=\"language-text\">let</code> beziehungsweise <code class=\"language-text\">const</code> deklariert wird, ist das <code class=\"language-text\">window</code> Objekt geschützt, es wird nicht verändert.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(window.RegExp); // Ausgabe: function RegExp()\nlet RegExp = &quot;Neuer Wert für RegExp&quot;;\nconsole.log(window.RegExp); // Ausgabe: function RegExp()\nconsole.log(RegExp); // Ausgabe: &quot;Neuer Wert für RegExp&quot;\n&lt;!--index_981.html --&gt;</code></pre></div>\n<p>Dadurch, dass das globale <code class=\"language-text\">window</code>-Objekt im Falle von <code class=\"language-text\">let</code> beziehungsweise <code class=\"language-text\">const</code> nicht geändert wird, ist die Variablenzuweisung sicherer. Es ist nicht möglich, dass Eigenschaften im <code class=\"language-text\">window</code>-Objekt unbewusst überschrieben werden. </p>\n<blockquote>\n<p>Die Verwendung von <code class=\"language-text\">var</code> kann zur Deklaration einer globalen Variablen dennoch sinnvoll sein. Den: Auf diese Art und Weise ist es möglich Variablen aus unterschiedlichen HTML-Dokumenten gleichzeitig zu verwenden.</p>\n</blockquote>\n<h2 id=\"erfolgsmethode---best-practice\"><a href=\"#erfolgsmethode---best-practice\" aria-label=\"erfolgsmethode   best practice permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Erfolgsmethode - best practice</h2>\n<p>Während der Entwicklung von ECMAScript 6 herrschte weit verbreitete Überzeugung, dass man für die Variablendeklarationen standardmäßig let anstelle von var verwendet. Für viele JavaScript-Entwickler ist das Verhalten dann genau so, wie sie es von var erwartet haben. Daher ist die direkte Ersetzung logisch. const wird nach dieser Überzeugung für Variablen verwenden, die einen Änderungsschutz benötigen.</p>\n<p>Als mehr Entwickler die neuen Deklarationen nutzten, wurde ein alternativer Ansatz immer beliebter: Verwenden Sie const standardmäßig und verwenden Sie let nur, wenn Sie wissen, dass sich der Wert einer Variablen ändert. Grundprinzip ist, das Variablen nur änderbar sind, wenn dies notwendig ist, da unerwartete Wertänderungen eine Fehlerquelle darstellen.</p>\n<h2 id=\"alles-noch-einmal-zusammengefasst\"><a href=\"#alles-noch-einmal-zusammengefasst\" aria-label=\"alles noch einmal zusammengefasst permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Alles noch einmal zusammengefasst</h2>\n<p>let- und const führen in JavaScript neue Gültigkeitsbereiche ein. Diese Deklarationen werden an den Anfang des Blocks verschoben. Sie existieren nur innerhalb des Blocks, in dem sie deklariert sind. Dieses Verhalten ist intuitiv und verhindert, dass unbeabsichtigte Fehler auftreten. Variablen werden jetzt genau dort deklariert, wo sie benötigt werden. Als Nebeneffekt ist es nicht möglich, dass sichere Operatoren wie typeof nicht auf Variablen zugreifen, bevor diese deklariert wurden. Der Versuch, vor ihrer Deklaration auf eine Variable zuzugreifen, führt zu einem Fehler, da die Bindung in der temporalen Totzone (TDZ) vorhanden ist.</p>\n<p>In vielen Fällen verhalten sich let und const ähnlich wie var. Dies gilt nicht für Schleifen. Sowohl für let als auch für const erstellen for-in- und for-of-Schleifen mit jeder Iteration durch die Schleife eine neue Bindung. Das bedeutet, dass Funktionen, die innerhalb des Schleifenkörpers erstellt wurden, auf die Schleifenbindungswerte zugreifen können, wie sie während der aktuellen Iteration sind, und nicht wie nach der letzten Iteration der Schleife (das Verhalten mit var). Gleiches gilt für let-Deklarationen in for-Schleifen, während der Versuch, const-Deklarationen in einer for-Schleife zu verwenden, in der Regel zu einem Fehler führt.</p>\n<p>Die derzeitige bewährte Methode für Blockbindungen besteht darin, standardmäßig const zu verwenden und let nur zu verwenden, wenn Sie wissen, dass sich der Wert einer Variablen ändert. Dies stellt ein grundlegendes Maß an Unveränderlichkeit im Code sicher, das dazu beiträgt, Fehlern zu vermeiden.</p>\n<h2 id=\"referenzen-und-externe-links\"><a href=\"#referenzen-und-externe-links\" aria-label=\"referenzen und externe links permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Referenzen und externe Links</h2>","timeToRead":19,"excerpt":"JavaScript wird oft als Spielzeug abgewertet. Dabei besitzt die Skriptsprache neben ihrer Einfachheit bedeutende Sprachfunktionen…","frontmatter":{"title":"ECMAScript 6 - Gueltigkeitsbereiche von Variablen","thumbnail":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB+klEQVQ4y5VVS8tBURT1X8yVjA3FxE8wNZSBgfITzJR/IQOZSSkpIyaSIoS83+/nXV9r953r4t4v367dPec4rb322nsfNmh3aPjONE37cHWuzKZpD1lMp1OMRiNMJhOMx2PxxWIh58vlEsfj0TKA0XTA4XCI+/3+4Y/HA7vdTsAZZD6fy56/GYGfgL8LXv7GyHS1Wkk2BDdJWfsANGpjphntdrsJqCUgddput+LvYDSmrpxGlkzdEnC/36PdbqPT6XykadQLBokUuCkgozWbTQwGA50xC7HZbGTf7XZRqVQE5HQ6mer3wbBWq0nb0NLpNBwOB+r1OlKpFCKRCOLxOMLhsNw9HA6mraMDMi0yICtar9eD1+uVyy6XC+VyWc6z2axeQIvGfopeKpX0yK1WCx6PRy4nk0nY7XYkEgmcz2ddBovGfkbJ5/O4Xq+yZ3F8Pp9eyWq1CrfbDb/fb9oFL4DKOS25XA6FQgGNRkNSZnFisZhcpiROp1OvuimgUYPL5YJisYhgMIhQKIRMJiPngUAA0WhUzhhQSfQO9sJQPRBMmToqndbrtTjZs10UmJW9MKReTFEZW0gBG5v8z+fLeEB2qm1ms5lI8M0bacmQA89p6ff7MtNMUTUx2fNr9PfR49f2HoVakR1T53iRsZWbVdv21+v7n78Ftf4B74PwQpk8V48AAAAASUVORK5CYII=","width":150,"height":150,"src":"/static/4d12485fc6f652067e12c34c5d10a065/4148e/js.png","srcSet":"/static/4d12485fc6f652067e12c34c5d10a065/4148e/js.png 1x"}}},"slug":"gueltigkeitsbereiche-von-variablen","date":"2019-08-01T00:00:00.000Z","categories":["JavaScript"],"tags":["ecmascript","javascript"],"template":"post"},"fields":{"slug":"/gueltigkeitsbereiche-von-variablen/","date":"2019-08-01T00:00:00.000Z"}}},"pageContext":{"slug":"/gueltigkeitsbereiche-von-variablen/"}}}