{"componentChunkName":"component---src-templates-post-js","path":"/gueltigkeitsbereiche-von-variablen/","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://de.wikipedia.org/w/index.php?title=JavaScript&#x26;oldid=184218223#Versionsgeschichte_von_ECMAScript_(ECMA-262\">https://de.wikipedia.org/w/index.php?title=JavaScript&#x26;oldid=184218223#Versionsgeschichte_von_ECMAScript_(ECMA-262</a>)  </p>\n<h2 id=\"in-diesem-kapitel-werden-wir-\"><a href=\"#in-diesem-kapitel-werden-wir-\" aria-label=\"in diesem kapitel werden wir  permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>In diesem Kapitel werden wir …</h2>\n<p>Zunächst zeige ich Ihnen, wie Sie\nTodo Meldungen immer mit Firefox</p>\n<h2 id=\"var---deklaration-und-hoisting\"><a href=\"#var---deklaration-und-hoisting\" aria-label=\"var   deklaration und hoisting permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>var - Deklaration und Hoisting</h2>\n<p><a href=\"https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/var#var_hoisting\">https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/var#var_hoisting</a>\ntodo was ist deklaration</p>\n<p>Die Deklartion einer Variablen erfolgt immer </p>\n<ul>\n<li>im globalen Kontekt falls die Variable außerhalb einer Funktion deklariert wurde oder </li>\n<li>ganz am Anfang einer Funktion.  </li>\n</ul>\n<p>Konkret bedeutet das, dass das Deklarieren einer Variable irgendwo im Programmcode\ndas gleiche ist, als würde sie am Anfang deklariert werden. Eine Variable\nkann somit genutzt werden, bevor sie im Programmcode deklariert wurde.\nDies nennt man <code class=\"language-text\">hoisting</code>.  </p>\n<blockquote>\n<p>Exkurs: Der Unterschied zwischen instanziieren, deklarieren und initialisieren<br>\nVariable instanzieren:<br>\nDer Begriff Instanziierung meint das Erzeugen eines neuen Objekts,\nalso einer Instanz, aus einer Klasse.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Objekt value = new Objekt();\n// value ist Instanz der Klasse Objekt</code></pre></div>\n<p>Variable deklarieren:<br>\nUnter deklarieren einer Variable können Sie sich das erste <em>Erwähnen der Variable</em>\nvorstellen. So weiß der Compiler, dass es die Variable gibt und kann sie ansprechen.\nDer Wert selbst wird bei der Deklaration nicht festgelegt.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">int value;\n// value als Variable des Typs int deklariert</code></pre></div>\n<p>Variable initialisieren:<br>\nEine Initialisierung ist das erste Zuweisen eines Wertes zu einer Variablen.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">value = 0;\n// value mit Wert 0 initialisiert</code></pre></div>\n<p>Sehen wir uns <code class=\"language-text\">hoisting</code> an einem Beispiel genauer an.</p>\n<h3 id=\"beispiele\"><a href=\"#beispiele\" aria-label=\"beispiele permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Beispiele</h3>\n<h4 id=\"beispiel-1\"><a href=\"#beispiel-1\" aria-label=\"beispiel 1 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Beispiel 1</h4>\n<p>Sehen Sie sich die nachfolgende Funktion einmal kurz an. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    if (false) {\n        var value = &quot;Prima&quot;;\n        return value;\n    } else {\n        return value; // gibt &quot;undefined&quot; oder &quot;&quot; aus, abhängig vom Browser.\n    }\n}\n&lt;!--index_999a.html--&gt;</code></pre></div>\n<p>Wenn Sie noch nicht vertraut mit JavaScript sind, erwarten Sie vielleicht, dass die\nVariable <code class=\"language-text\">value</code> nur erstellt wird, wenn die Bedingung in der\n<code class=\"language-text\">if</code>-Anweisung <code class=\"language-text\">true</code> ist. In der Realtiät ist es aber so, dass die Variable\nauf alle Fälle erstellt wird.</p>\n<p>Im Hintergrund verändert JavaScipt den Programmcode nämlich. Der\n<a href=\"https://de.wikipedia.org/w/index.php?title=Interpreter&#x26;oldid=182588640\">Interpreter</a> macht\ndaraus konkret den folgenden Aufruf.\nDie wesentliche Zeile habe ich mit einem Stern markiert.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n*    var value;\n     if (false) {\n         var value = &quot;Prima&quot;;\n         return value;\n     } else {\n         return value; // gibt &quot;undefined&quot; oder &quot;&quot; aus, abhängig vom Browser.\n     }\n     // die Variable value existiert auch hier\n }\n&lt;!--index_999a.html aus Sicht des Interpeters--&gt;</code></pre></div>\n<p>Die Deklaration der Variablen <code class=\"language-text\">value</code> wird an den Anfang der Funktion verschoben.\nUnd die Initialisierung erfolgt im gleichen Gültigkeitsbereich. Dadurch kann im\n<code class=\"language-text\">else</code>-Block auf die Variablen <code class=\"language-text\">value</code> zugegriffen werden. Da die Variablen <code class=\"language-text\">value</code> im\n<code class=\"language-text\">else</code>-Block mit keinem Wert belegt ist, gibt sie bei einem Zugriff <code class=\"language-text\">undefined</code>\nanstelle von <code class=\"language-text\">ReferenceError: myvalue is not defined</code> aus. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n     if (false) {\n         var value = &quot;Prima&quot;;\n         return value;\n     } else {\n*        return myvalue; // gibt &quot;ReferenceError: myvalue is not defined&quot; aus\n     }\n }\n&lt;!--index_999c.html --&gt;</code></pre></div>\n<p><code class=\"language-text\">Hoisting</code> führt sehr oft zu Missverständnissen. Für viele Entwickler ist es\nbefremdend, dass eine Variable nicht an der Stelle erstellt wird, an der sie im\nProgrammcode steht. Wahrscheinlich wurde deshalb mit ECMAScript 6\ndie Möglichkeit eingeführt,\nVariablen im Gültigkeitsbereich des lokalen Blocks zu deklarieren.</p>\n<p><a href=\"https://www.mediaevent.de/javascript/globale-lokale-variablen.html\">https://www.mediaevent.de/javascript/globale-lokale-variablen.html</a></p>\n<h2 id=\"gultigkeitsbereich-scope-im-block\"><a href=\"#gultigkeitsbereich-scope-im-block\" aria-label=\"gultigkeitsbereich scope im block permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gültigkeitsbereich (Scope) im Block</h2>\n<p>In vielen Programmiersprachen gibt es den Block Scope – alle Variablen,\ndie innerhalb eines Blocks deklariert werden, gelten nur innerhalb dieses Blocks.\nDiese Variablen sind lokale Variablen.</p>\n<p>Was genau ist ein Block? Ein Block ist entweder </p>\n<ul>\n<li>der Bereich innerhalb einer Funktion oder</li>\n<li>ein Bereich der mit geschweiften Klammern - <code class=\"language-text\">{</code> und <code class=\"language-text\">}</code> - umgeben ist. </li>\n</ul>\n<p>Variablen, die mit <code class=\"language-text\">let</code> oder <code class=\"language-text\">const</code> angelegt werden, gelten nur innerhalb\nihres Blocks. Das klingt unbequem. Es verhindert aber viele schwer\naufzudeckende Fehler. </p>\n<h3 id=\"block-scope-mit-let\"><a href=\"#block-scope-mit-let\" aria-label=\"block scope mit let permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Block Scope mit let</h3>\n<p>Mit ECMAScript 6 ist <code class=\"language-text\">let</code> für die Deklaration von Variablen hinzugekommen.\nEine mit <code class=\"language-text\">let</code> deklarierte Variable hat einen eingeschränkten Gültigkeitsbereich.\nSie ist nur innerhalb des Blocks, in dem sie deklariert wurden, gültig. </p>\n<p>Die Deklaration einer Variablen mit <code class=\"language-text\">let</code> erfolgt auf die gleiche Art\nwie die Deklaration einer Variablen mit <code class=\"language-text\">var</code>. Was wäre, wenn die Variable im\nvorherigen Beispiel anstelle von var mit let deklariert worden wäre? Genau dies\nzeigt Ihnend das nachfolgende Beispiel.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n     if (true) {\n         let value = &quot;Prima&quot;;\n     } else {\n*        return value; // Würde &quot;ReferenceError: value is not defined&quot; ausgeben.\n     }\n*    return value; // Gibt &quot;ReferenceError: value is not defined&quot; aus.\n}\n&lt;!--index_998d.html --&gt;</code></pre></div>\n<p>Haben Sie den Programmcode ausprobiert? Dann stimmen Sie sicher mit mir überein,\ndas die Ausgabe der Datei <code class=\"language-text\">998d.html</code> intuitiver ist als die Ausgabe\nder Datei <code class=\"language-text\">999a.html</code>. Weil wir die Variable <code class=\"language-text\">value</code> mit <code class=\"language-text\">let</code> deklariert haben,\nwird die Deklaration nicht im Hintergrund vom Interpeter an den Anfang der\nFunktion verschoben. Ein Zugriff auf die Variable <code class=\"language-text\">value</code> ist nun außerhalb\nder <code class=\"language-text\">if</code>-Anweisung nicht möglich. Da die Variable <code class=\"language-text\">value</code> nur deklariert wird,\nwenn die Bedingung der <code class=\"language-text\">if</code>-Anweisung erfüllt ist, kann auch im <code class=\"language-text\">else</code>-Block\nnicht auf diese zugegriffen werden. Das nächste Beispiel zeigt Ihnen,\ndass die Deklaration der Variable <code class=\"language-text\">value</code> am Anfang des Blocks in dem diese\ngültig ist erfolgt. Auf die Variable <code class=\"language-text\">value</code> kann erst nach der Deklaration\nzugegriffen werden. Allerdings ist die Fehlermeldung innerhalb des Blocks,\nindem die Variable deklariert wird, eine andere. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    if (true) {\n        return value; // gibt &quot;ReferenceError: can&#39;t access lexical \n                      //declaration `value&#39; before initialization&quot; ausgeben.\n        let value = &quot;Prima&quot;;\n    } else {\n        return value; // würde &quot;ReferenceError: value is not defined&quot; ausgeben.\n    }\n}\n&lt;!--index_998e.html --&gt;</code></pre></div>\n<h3 id=\"keine-mehrfachverwendung\"><a href=\"#keine-mehrfachverwendung\" aria-label=\"keine mehrfachverwendung permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Keine Mehrfachverwendung</h3>\n<p>Die Mehrfachverwendung einer mit <code class=\"language-text\">let</code> deklarierten\nVariablen innerhalb eines Blocks ist nicht möglich. Falls Sie dies versehentlich\ndoch tun, wird der JavaScript Interpreter Ihnen den Fehler\n<code class=\"language-text\">SyntaxError: redeclaration of let value</code> melden.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n     var value = &quot;Prima&quot;;\n*    let value = &quot;Prima&quot;;  // SyntaxError: redeclaration of let value\n }\n&lt;!--index_997.html --&gt;</code></pre></div>\n<p>Im vorhergehenden Beispiel wurde die Variable <code class=\"language-text\">value</code> zweimal deklariert. Einmal\nmit <code class=\"language-text\">var</code> und einmal mit <code class=\"language-text\">let</code>. Weil diese beiden Variablen im selben\nGültigkeitsbereich deklariert wurden, tritt ein Fehler auf. </p>\n<p>Im Umkehrschluss ist es möglich, eine Variable mit dem gleichen Namen in einem\nuntergeordneten Gültigkeitsbereich zu deklarieren.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n     var value = &quot;Prima&quot;;\n     if (true) {\n*        let value = &quot;Prima&quot;;\n     return true;\n }\n&lt;!--index_997c.html --&gt;</code></pre></div>\n<p>Im Beispiel der Datei <code class=\"language-text\">997c.html</code> tritt kein Fehler auf. Die Variable <code class=\"language-text\">value</code>\nwird in der <code class=\"language-text\">if</code>-Anweisung neu deklariert. Die Deklaration erfolgt genau\nan der Stelle, an der der Programmierer sie in den Programmcode einfügt.\nDie Deklaration wird also nicht wie\nim Falle von <code class=\"language-text\">var</code>, an den Beginn des umgebenden Blocks gesetzt. </p>\n<h3 id=\"block-scope-mit-const\"><a href=\"#block-scope-mit-const\" aria-label=\"block scope mit const permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Block Scope mit const</h3>\n<p>Die Deklaration einer Variablen mit <code class=\"language-text\">const</code> erstellt eine Konstante.\nDer Gültigkeitsbereich einer mit <code class=\"language-text\">const</code> deklarierten Variablen ist,\ngenau wie bei einer mit <code class=\"language-text\">let</code> deklarierten Variable, auf den lokalen Block begrenzt.\nDer Wert einer Konstanten muss bei der Deklaration initialisiert werden und\nkann später nicht verändert werden.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    const value1 = &quot;Prima&quot;;\n    const value2; // SyntaxError: missing = in const declaration\n}\n&lt;!--index_996.html --&gt;</code></pre></div>\n<p>Im vorherigen Beispiel wird die Variable <code class=\"language-text\">value1</code> korrekt deklariert und initialisiert.\nDie Deklaration der Variable <code class=\"language-text\">value2</code> ist nicht möglich. Hier wird ein Fehler\nangezeigt, weil <code class=\"language-text\">value2</code> beim Anlegen nicht initialisiert wurde.</p>\n<h4 id=\"const-versus-let\"><a href=\"#const-versus-let\" aria-label=\"const versus let permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>const versus let</h4>\n<p>Genau wie im Falle von <code class=\"language-text\">let</code> ist eine mit <code class=\"language-text\">const</code> deklarierte Variable ausschießlich\ninnerhalb eines Blocks gültig. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n     if (true) {\n*        const value = &quot;Prima&quot;;\n     }   \n     return value; //ReferenceError: value is not defined\n }\n&lt;!--index_995.html --&gt;</code></pre></div>\n<p>Eine weitere Gemeinsamkeit von <code class=\"language-text\">let</code> und <code class=\"language-text\">const</code> ist die nicht mögliche\nMehrfachverwendung.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n     var value1 = &quot;Prima&quot;;\n     let value2 = &quot;Super&quot;;\n*    const value1 = &quot;Prima&quot;; // SyntaxError: redeclaration of var value1\n*    const value2 = &quot;Super&quot;; // SyntaxError: redeclaration of var value2\n     return true;\n }\n&lt;!--index_994.html --&gt;</code></pre></div>\n<p>Abgesehen von diesen Gemeinsamkeiten gibt es einen bedeutenden Unterschied. Anders\nals bei einer mit <code class=\"language-text\">let</code> deklarierten Variablen kann der Wert einer Konstanten\nim Nachhinein nicht geändert werden.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n     let value1 = &quot;Prima&quot;;\n     const value2 = &quot;Super&quot;;\n     value1 = &quot;Toll&quot;;\n*    value2 = &quot;Schön&quot;; // TypeError: invalid assignment to const `value2&#39;\n     return true;\n }\n&lt;!--index_993.html --&gt;</code></pre></div>\n<h4 id=\"const-und-objekte\"><a href=\"#const-und-objekte\" aria-label=\"const und objekte permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>const und Objekte</h4>\n<p>Erklärungsbedürftig ist die Behandlung von Konstanten in JavaScript, wenn ein\nObjekt als Konstante deklariert wurde. In diesem Falle ist nur das Objekt\nselbst konstant. Die Eigenschaften des Objektes können verändert werden.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    const stadt = {\n        name: &quot;Koblenz&quot;\n    }\n    stadt.name = &quot;Bonn&quot;; // Mögliche Neuzuweisung\n    stadt.fluss = &quot;Rhein&quot;; // Mögliche Neuzuweisung\n    \n    const stadt = { // SyntaxError: redeclaration of const stadt\n        name: &quot;Bonn&quot; \n    } \n    return true;\n}\n&lt;!--index_992.html --&gt;</code></pre></div>\n<h3 id=\"die-vorubergehend-tote-zone\"><a href=\"#die-vorubergehend-tote-zone\" aria-label=\"die vorubergehend tote zone permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Die vorübergehend tote Zone</h3>\n<p>Variablen, die mit <code class=\"language-text\">let</code> oder <code class=\"language-text\">const</code> angelegt werden, gelten nur innerhalb\nihres Blocks. Dies führt in JavaScript zu einem Zustand der sich gefährlich\nanhört: <em>Der vorübergehend toten Zone</em>. Der englische Ausdruck dafür ist\n<em>Temporal Dead Zone (TDZ)</em>. In der <em>vorübergehend toten Zone</em> tritt beim Zugriff\nauf eine deklarierte Variable, ein Fehler auf. Verhängnisvoll ist, dass\ndieser Fehler auch dann auftritt, wenn eine vermeintlich sichere\nMethode wie <code class=\"language-text\">typeof</code> verwendet wird.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n     console.log(typeof value1); // Ausgabe: undefined\n*    console.log(typeof value2); // ReferenceError: can&#39;t access lexical declaration\n                                 // `value2&#39; before initialization\n     let value2 = &quot;Prima&quot;; \n    return true;\n}\n&lt;!--index_991.html --&gt;</code></pre></div>\n<p>In vorhergehenden Beispiel wird auf die Variablen <code class=\"language-text\">value1</code> und\n<code class=\"language-text\">value2</code> mithilfe von <code class=\"language-text\">typeof</code>\nzugegriffen. Im Falle von <code class=\"language-text\">value1</code> ist dies auch kein Problem. Bei <code class=\"language-text\">value2</code>\ntritt hingegen ein Fehler auf, weil <code class=\"language-text\">value2</code> im gleichen\nGültigkeitsbereich später noch einmal mit <code class=\"language-text\">let</code> deklariert wird.  </p>\n<p>Die gleiche Deklaration in einem\nanderen Gültigkeitsbereich\nwäre kein Problem, wie Beispiel <code class=\"language-text\">index_991c.html</code> zeigt. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    console.log(typeof value1); // Ausgabe: undefined\n    console.log(typeof value2); // Ausgabe: undefined\n\n    if (true) {\n        let value2 = &quot;Prima&quot;;\n    }\n        \n    return true;\n}\n&lt;!--index_991c.html --&gt;</code></pre></div>\n<blockquote>\n<p>Die Bezeichnung <em>Temporal Dead Zone (TDZ)</em> sucht man in der Spezifikation\n<em>ECMAScript 6</em> vergeblich. Der Begriff wird aber häufig zur Erklärung eingesetzt. Die\nTDZ entsteht, weil der JavaScript-Interpreter sich einen Block schon beim Einlesen\nvollständig ansieht. Wenn er eine mit <code class=\"language-text\">var</code> deklarierte Variable findet, dann setzt er die\nDeklaration an den Beginn der Funktion oder in den globalen Gültigkeitsbereich. Findet\nder Interpreter eine mit <code class=\"language-text\">let</code> oder <code class=\"language-text\">const</code> deklarierte Variable, dann setzt er diese\nin die TDZ - solange, bis die eigenliche Deklaration erfolgt.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n     console.log(typeof value); // Ausgabe: undefined\n*    if (true) {\n*        let value = &quot;Prima&quot;;\n*        console.log(typeof value); // Ausgabe: String\n*    }\n     console.log(typeof value); // Ausgabe: undefined\n     return true;\n }\n&lt;!--index_991a.html --&gt;</code></pre></div>\n<p>Die Variable <code class=\"language-text\">value2</code> befindet sich nicht in der TDZ wenn der Befehl\n<code class=\"language-text\">console.log(typeof value)</code> ausgeführt wird. Das bedeutet konkret, dass die Variable\nfrei aber tatsächlich <code class=\"language-text\">undefinded</code> ist.</p>\n<blockquote>\n<p>Die Beispiele zur TDZ verwenden hier mithilfe von <code class=\"language-text\">let</code> deklarierte Variablen. Das\nGleiche gilt aber auch für Variablen, die mit <code class=\"language-text\">const</code> deklariert wurden.</p>\n</blockquote>\n<h2 id=\"gultigkeitsbereich-scope-in-schleifen\"><a href=\"#gultigkeitsbereich-scope-in-schleifen\" aria-label=\"gultigkeitsbereich scope in schleifen permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gültigkeitsbereich (Scope) in Schleifen</h2>\n<p>Eine weitere Besonderheit von JavaScript ist der Gültigkeitsbereich innerhalb von\nSchleifen. Beim Druchlaufen\nvon Schleifen bringt es viele Vorteile wenn die Gültikeitesbereiche der Variablen\nübersichtlich und getrennt sind. In einer Schleife wird häufig eine Variable als Zähler\nverwendet. Das nächste Beispiel zeigt Ihnen, dass der Gültigkeitsbereich einer\nsolchen Zählervariablen nicht übersichtlich und getrennt ist, wenn diese Variable\nmit <code class=\"language-text\">var</code> deklariert wird. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n     for (var i = 0; i &lt; 5; i++) {\n         // tue etwas ...\n     }\n*    console.log(i); // Ausgabe: 5\n     return true;\n }\n&lt;!--index_990.html --&gt;</code></pre></div>\n<p>Auch nachdem der Schleifendurchlauf abgeschlossen ist und der Block verlassen wurde,\nist die Variable <code class=\"language-text\">i</code> noch gültig. Der letzte Wert der Variablen wird mittels\n<code class=\"language-text\">console.log(i)</code> ausgegeben. Dies ist ein Verhalten, das nicht erwünscht ist. Die\nVariable <code class=\"language-text\">i</code> wird in der Regel nur lokal in der Schleife benötigt und sollte auch\nnur hier ihren Gültigkeitsbereich haben. Bei der Verwendung von <code class=\"language-text\">var</code> zur Deklaration\nwird diese Deklaration aufgrund von\n<a href=\"https://de.wikipedia.org/w/index.php?title=Hoisting&#x26;oldid=166784898\">Hoisting</a>\nan den Anfang der Funktion geschoben und ist somit innerhalb der vollständigen\nFunktion gültig.</p>\n<p>Das nächste Beispiel nutzt anstelle von <code class=\"language-text\">var</code> eine mit <code class=\"language-text\">let</code> deklarierte Variabel als\nZähler. Das Ergebnis ist das erwartete Verhalten.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> function getValue() {\n     for (let i = 0; i &lt; 5; i++) {\n         console.log(i); // Ausgabe: 0 1 2 3 4\n     }\n*    console.log(i); // ReferenceError: i is not defined\n     return true;\n }\n&lt;!--index_989.html --&gt;</code></pre></div>\n<p>Das Beispiel der Datei <code class=\"language-text\">index_989.html</code> demonstriert das gewünschte Verhalten. Die\nVariable <code class=\"language-text\">i</code> existiert nur innerhalb der Schleife. Nachdem die Schleife abgearbeitet\nist, kann auf die Variable <code class=\"language-text\">i</code> nicht mehr zugegriffen werden. Die Variable <code class=\"language-text\">i</code> kann<br>\nkeine Verwirrung mehr stiften.</p>\n<h3 id=\"funktionen-in-schleifen\"><a href=\"#funktionen-in-schleifen\" aria-label=\"funktionen in schleifen permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Funktionen in Schleifen</h3>\n<p>Hoisting und das Verhalten von <code class=\"language-text\">var</code> machen das Arbeiten mit Funktionen in Schleifen\nunvorhersehbar. Das nächste Beispiel zeigt Ihnen, auf was ich genau hinaus will.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    for (var i = 0; i &lt; 5; i++) {\n        funktionen.push(function() {\n            console.log(i);\n        });\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); // Ausgabe: Fünfmal die Nummer &quot;5&quot;\n    });\n    return true;\n}\n&lt;!--index_988.html --&gt;</code></pre></div>\n<p>Haben Sie die Ausgabe <code class=\"language-text\">0 1 2 3 4</code> erwartet? Anstelle davon wurde aber\n<code class=\"language-text\">5 5 5 5 5</code> ausgegeben. Der Grund hierfür ist, dass dieselbe Variable <code class=\"language-text\">i</code> über alle\nIterationen der Schleife hinweg geteilt wird. Aufgrund von Hoisting wurde\ndie Variable <code class=\"language-text\">i</code> außerhalb der Schleife deklariert. Alle Funktionen, die in der\nSchleife erstellt wurden, halten eine Referenz auf die selbe Variable <code class=\"language-text\">i</code>.\nDiese Variable <code class=\"language-text\">i</code> hat den Wert <code class=\"language-text\">5</code>, wenn alle Schleifendurchläufe beendet sind.\nWenn dann <code class=\"language-text\">console.log(i)</code> aufgrund von </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">funktionen.forEach(function(funktion){\n    funktion(); \n});</code></pre></div>\n<p>fünfmal ausgeführt wird, wird der Wert <code class=\"language-text\">5</code> fünfmal ausgegeben.  </p>\n<p>Eine Lösung für dieses Problem ist\n<a href=\"https://wiki.selfhtml.org/index.php?title=IIFE&#x26;oldid=59916\">IIFE</a>.\n<em>IIFE</em> steht für <em>Immediately-invoked Function Expression</em>,\nalso ein sofort ausgeführter Funktionsausdruck. Das hört sich sehr kompliziert\nan. Meiner Meinung nach\nist es auch kompliziert. Ich habe <em>IIFE</em> hier der Vollständigkeit halber\naufgenommen.\nIm nächsten Kapitel finden Sie eine einfachere Lösung - seit ECMAScript 6.  </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    for (var i = 0; i &lt; 5; i++) {\n        funktionen.push((function(value) {\n            return function (){\n                console.log(value);\n            }\n        }(i)));\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); // Ausgabe: 0 1 2 3 4 \n    });\n    return true;\n}\n&lt;!--index_987.html --&gt;</code></pre></div>\n<p>Das Beispiel der Datei <code class=\"language-text\">index_987.html</code> verwendet eine IIFE. Das Grundgerüst\neiner IIFE finden Sie im nächsten Programmcodebeispiel.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(function (foo) {\n    //...\n})(foo);</code></pre></div>\n<p>Dieses Grundgerüst sieht noch recht einfach aus. Beispiel <code class=\"language-text\">index_987.html</code> wirkt hingegen\nrecht kompliziert. Deshalb sehen wir uns die relevanten Teile genauer an.\nDie Variable <code class=\"language-text\">i</code> wird im Beispiel <code class=\"language-text\">index_987.html</code> an die IIFE übergeben. Im\nnachfolgenden Programmcodebeispiel habe ich die IIFE des Beispiel <code class=\"language-text\">index_987.html</code>\nfür sich alleine eingefügt.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">...\n...(function(value) {\n       return function (){\n           console.log(value);\n       }\n   }(i))...\n...</code></pre></div>\n<p>Die IIFE speichert die\nVariable <code class=\"language-text\">i</code> in einer eigenen Kopie. In unserem Beispiel erhält diese Kopie\nden Namen <code class=\"language-text\">value</code>. Die Kopie der Variablen <code class=\"language-text\">i</code>, also <code class=\"language-text\">value</code> wird nun in der\nFunktion verwendet. Dies führt dazu, dass die Ausgabe der Schleife nun eher der\nErwartung eines Programmierers entspricht, als die Ausgabe der Schleife in Beispiel\n<code class=\"language-text\">index_988.html</code>.\nWie schon erwähnt bietet ECMAScript 6 glücklicherweise eine einfacherer Möglichkeit,\ndiese Ausgabe zu erreichen. Und  diese Möglichkeit sehen wir uns im nächsten Kapitel an.</p>\n<h3 id=\"let-in-schleifen\"><a href=\"#let-in-schleifen\" aria-label=\"let in schleifen permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>let in Schleifen</h3>\n<p>Eine mit let deklarierte Variable <code class=\"language-text\">i</code> in der Schleifenbedingung vereinfacht\ndie arbeit mit der Schleife ungemein.\nBei jedem Schleifendurchlauf wird aufgrund von <code class=\"language-text\">let</code> eine neue Variable <code class=\"language-text\">i</code>\nerstellt und mit dem aktuellen\nWert initialisiert. Das nächste Beispiel zeigt Ihnen, dass man so vollständig\nauf das komplizierte\nIIFE Konstrukt verzichten kann.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    for (let i = 0; i &lt; 5; i++) {\n        funktionen.push(function() {\n            console.log(i);\n        });\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); // Ausgabe: 0 1 2 3 4\n    });\n    return true;\n}\nwindow.addEventListener(&quot;load&quot;, function () {\nconsole.log(getValue());\n});\n&lt;!--index_986.html --&gt;</code></pre></div>\n<p>Das Beispiel der Datei <code class=\"language-text\">index_986.html</code> errechnet genau das, was das Beispiel\nder Datei <code class=\"language-text\">index_987.html</code> errechnete - allerdings auf eine wesentlich\nkomfortable Art.</p>\n<p>todo for in und for of erklären?</p>\n<p>Mit dem Beispiel der Datei <code class=\"language-text\">index_985.html</code> können Sie sich davon überzeugen, dass das\nwas ich gerade für eine forEach Schleife beschrieben habe, auch auf <code class=\"language-text\">for-in</code> und <code class=\"language-text\">for-of</code>\nSchleifen zutrifft.  </p>\n<p><code class=\"language-text\">for-of</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    var names = [&#39;Astrid&#39;, &#39;Nina&#39;, &#39;Elmar&#39;];\n    \n    for (let name of names) {\n        funktionen.push(function() {\n            console.log(name);\n        });\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); \n    });\n    return true;\n}\n&lt;!--index_985.html --&gt;</code></pre></div>\n<p><code class=\"language-text\">for-in</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    var object = {\n        1 : &quot;a&quot;,\n        2 : &quot;b&quot;,\n        3 : &quot;c&quot;\n    };\n    \n    for (let key in object) {\n        funktionen.push(function() {\n            console.log(key);\n        });\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); \n    });\n    return true;\n}\n&lt;!--index_984.html --&gt;</code></pre></div>\n<p>In den Beispielen zur <code class=\"language-text\">for-in</code>-Schleife und zur <code class=\"language-text\">for-of</code>-Schleife wird bei jedem\nSchleifendurchlauf eine Kopie von <code class=\"language-text\">key</code> angelegt. Dies geschieht, weil <code class=\"language-text\">key</code>\nmit <code class=\"language-text\">let</code> deklariert wurde. Für die Ausgabe wird immre diese Kopier verwendet.\nDeshalb ist die Ausgabe im ersten Fall <code class=\"language-text\">Astrid Nina Elmar</code> und im zweiten Fall\n<code class=\"language-text\">1 2 3</code>.\nWenn <code class=\"language-text\">key</code> mit <code class=\"language-text\">var</code> deklariert würde, würde im ersten\nFall dreimal <code class=\"language-text\">Elmar</code> ausgegeben und im zweiten Fall dreimal <code class=\"language-text\">3</code>.</p>\n<h3 id=\"const-in-schleifen\"><a href=\"#const-in-schleifen\" aria-label=\"const in schleifen permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>const in Schleifen</h3>\n<p>Die ECMAScript 6 Spezifikation verbietet die Verwendung von Konstanten als\nSchleifenbedingung nicht. Wer eine Konstante als Schleifenbedingung verwenden\nmöchte, sollte sich die Zusammenhänge genau ansehen. Die <code class=\"language-text\">for-in</code>-Schleife und\ndie <code class=\"language-text\">for-of</code>-Schleife nutzen eine Konstante anders, als eine normale\n<code class=\"language-text\">for</code>-Schleife es tut.</p>\n<h4 id=\"for-schleife\"><a href=\"#for-schleife\" aria-label=\"for schleife permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>For-Schleife</h4>\n<p>In einer einfache For-Schleife ist es zwar erlaubt die Schleifenbedingung als\nKonstante zu initialisieren. Es ist aber in den meisten Fällen nicht sinnvoll.\nBei der Ausführung der Schleife wird nämlich ein Fehler gemeldet, wenn\nder Wert der Konstanten geändert werden soll.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    for (const i = 0; i &lt; 5; i++) {\n        funktionen.push(function() {\n            console.log(i);\n        });\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); // Ausgabe: TypeError: invalid assignment to const i\n    });\n    return true;\n}\n&lt;!--index_983.html --&gt;</code></pre></div>\n<p>Im vorhergehen Beispiel wird die Variable <code class=\"language-text\">i</code> als Konstante deklariert. Der erste\nSchleifendurchlauf ist erfolgreich. Bei diesem Schleifendurchlauf ist der Wert\nder Variablen <code class=\"language-text\">i</code> gleich <code class=\"language-text\">0</code>. Beim nächsten Schleifendurchlauf tritt dann allerdings\nein Fehler auf. Dieser Fehler tritt genau auf, wenn <code class=\"language-text\">i++</code> ausgeführt werden soll.\nDie Fehlermeldung lautet im Browser Firefox <code class=\"language-text\">TypeError: invalid assignment to const i</code>.  </p>\n<p>Das nächste Programmcodebeispiel zeigt ein etwas konstruiertes Beispiel.\nIm Beispiel wird\nin der Schleifenbedingung eine Konstante verwendet. Es tritt aber kein Fehler auf,\nweil die Schleife mit <code class=\"language-text\">break</code> abbricht, bevor <code class=\"language-text\">i++</code> ausgeführt wird.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    for (const i = 0; i &lt; 5;) {\n        funktionen.push(function() {\n            console.log(i);\n        });\n        break;\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); // Ausgabe: 0\n    });\n    return true;\n}\n&lt;!--index_983c.html --&gt;</code></pre></div>\n<h4 id=\"for-in-schleife-und-for-of-schleife\"><a href=\"#for-in-schleife-und-for-of-schleife\" aria-label=\"for in schleife und for of schleife permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>For-in-Schleife und For-of-Schleife</h4>\n<p>In einer <code class=\"language-text\">for-in</code>-Schleife oder einer <code class=\"language-text\">for-of</code>-Schleife kann hingegen mit einer\nKonstanten gearbeitet werden. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    var names = [&#39;Astrid&#39;, &#39;Nina&#39;, &#39;Elmar&#39;];\n    \n    for (const name of names) {\n        funktionen.push(function() {\n            console.log(name);\n        });\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); // Ausgabe: Astrid Nina Elmar\n    });\n    return true;\n}\n&lt;!--index_983a.html --&gt;</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getValue() {\n    var funktionen = [];\n    var object = {\n        1 : &quot;a&quot;,\n        2 : &quot;b&quot;,\n        3 : &quot;c&quot;\n    };\n    \n    for (const key in object) {\n        funktionen.push(function() {\n            console.log(key);\n        });\n    }\n    funktionen.forEach(function(funktion){\n        funktion(); // Ausgabe: 1 2 3\n    });\n    return true;\n}\n&lt;!--index_983b.html --&gt;</code></pre></div>\n<p>Der warum in einer <code class=\"language-text\">for-in</code>-Schleife oder einer <code class=\"language-text\">for-of</code>-Schleife eine Konstante\nals Schleifenbedingung keinen Fehler erzeugt ist bei genauem Hinsehen einfach. Beim\nSchleifendurchlauf wird keiner Konstanten ein anderer Wert zugeordnet. Es wird\nvielmehr die Zuordnung zu zur Konstanten <code class=\"language-text\">name</code> oder <code class=\"language-text\">key</code> geändert.</p>\n<h2 id=\"globaler-gultigkeitsbereich-scope\"><a href=\"#globaler-gultigkeitsbereich-scope\" aria-label=\"globaler gultigkeitsbereich scope permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Globaler Gültigkeitsbereich (Scope)</h2>\n<p>Auch im globalen Gültigkeitsbereich gibt es Unterschiede zwischen <code class=\"language-text\">var</code> und\nden ECMAScript 6- Neulingen <code class=\"language-text\">let</code> beziehungsweise <code class=\"language-text\">const</code>.  </p>\n<p>Zum einen überschreibt eine im globalen Gültigkeitsbereich mit <code class=\"language-text\">var</code>\ndeklarierte Variable die gleichnamige Eigenschaft im <code class=\"language-text\">window</code> Objekt.\nDas nachfolgende Beispiel verdeutlich das gerade beschriebene. So hat\nJavaScript in der Vergangenheit immer gearbeitet.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(window.RegExp); // Ausgabe: function RegExp()\nvar RegExp = &quot;Neuer Wert für RegExp&quot;;\nconsole.log(window.RegExp); // Ausgabe: &quot;Neuer Wert für RegExp&quot;\n&lt;!--index_982.html --&gt;</code></pre></div>\n<p>Wenn anstelle von <code class=\"language-text\">var</code> eine Variable im globalen Gültikeitsbereich mit <code class=\"language-text\">let</code>\nbeziehungsweise <code class=\"language-text\">const</code> deklariert wird wird das <code class=\"language-text\">window</code> Objekt nicht verändert.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(window.RegExp); // Ausgabe: function RegExp()\nlet RegExp = &quot;Neuer Wert für RegExp&quot;;\nconsole.log(window.RegExp); // Ausgabe: function RegExp()\n&lt;!--index_981.html --&gt;</code></pre></div>\n<p>Dadurch, dass das globale <code class=\"language-text\">window</code>-Objekt im Falle von <code class=\"language-text\">let</code>\nbeziehungsweise <code class=\"language-text\">const</code>nicht geändert wird, ist die Variablenzuweisunge\nsicherer. Das unbewusste überschreiben von Eigenschaften im <code class=\"language-text\">window</code>-Objekt kann\nnicht vorkommen.</p>\n<blockquote>\n<p>Die Verwendung von <code class=\"language-text\">var</code> kann zur Deklaration einer\nglobalen Variablen dennnoch sinnvoll sein. Auf diese Art und Weise können Variablen\nvon unterschiedlichen HTML-Dokumenten gleichzeitig genutzt werden.</p>\n</blockquote>\n<h2 id=\"erfolgsmethode---best-practice\"><a href=\"#erfolgsmethode---best-practice\" aria-label=\"erfolgsmethode   best practice permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Erfolgsmethode - best practice</h2>\n<blockquote>\n<p><strong>Achtung:</strong></p>\n</blockquote>\n<h2 id=\"in-diesem-kapitel-haben-wir-\"><a href=\"#in-diesem-kapitel-haben-wir-\" aria-label=\"in diesem kapitel haben wir  permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>In diesem Kapitel haben wir ...</h2>\n<p>xxx</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p><a href=\"https://de.wikipedia.org/w/index.php?title=Interpreter&#x26;oldid=182588640\">https://de.wikipedia.org/w/index.php?title=Interpreter&#x26;oldid=182588640</a> (<a href=\"https://bit.ly/2GT9nQS\">https://bit.ly/2GT9nQS</a>)</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","timeToRead":17,"excerpt":"https://de.wikipedia.org/w/index.php?title=JavaScript&oldid=184218223#Versionsgeschichte_von_ECMAScript_(ECMA-262)   In diesem Kapitel…","frontmatter":{"title":"ECMAScript 6 - Gueltigkeitsbereiche von Variablen","thumbnail":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB+klEQVQ4y5VVS8tBURT1X8yVjA3FxE8wNZSBgfITzJR/IQOZSSkpIyaSIoS83+/nXV9r953r4t4v367dPec4rb322nsfNmh3aPjONE37cHWuzKZpD1lMp1OMRiNMJhOMx2PxxWIh58vlEsfj0TKA0XTA4XCI+/3+4Y/HA7vdTsAZZD6fy56/GYGfgL8LXv7GyHS1Wkk2BDdJWfsANGpjphntdrsJqCUgddput+LvYDSmrpxGlkzdEnC/36PdbqPT6XykadQLBokUuCkgozWbTQwGA50xC7HZbGTf7XZRqVQE5HQ6mer3wbBWq0nb0NLpNBwOB+r1OlKpFCKRCOLxOMLhsNw9HA6mraMDMi0yICtar9eD1+uVyy6XC+VyWc6z2axeQIvGfopeKpX0yK1WCx6PRy4nk0nY7XYkEgmcz2ddBovGfkbJ5/O4Xq+yZ3F8Pp9eyWq1CrfbDb/fb9oFL4DKOS25XA6FQgGNRkNSZnFisZhcpiROp1OvuimgUYPL5YJisYhgMIhQKIRMJiPngUAA0WhUzhhQSfQO9sJQPRBMmToqndbrtTjZs10UmJW9MKReTFEZW0gBG5v8z+fLeEB2qm1ms5lI8M0bacmQA89p6ff7MtNMUTUx2fNr9PfR49f2HoVakR1T53iRsZWbVdv21+v7n78Ftf4B74PwQpk8V48AAAAASUVORK5CYII=","width":150,"height":150,"src":"/static/4d12485fc6f652067e12c34c5d10a065/4148e/js.png","srcSet":"/static/4d12485fc6f652067e12c34c5d10a065/4148e/js.png 1x"}}},"slug":"gueltigkeitsbereiche-von-variablen","date":"2019-08-01T00:00:00.000Z","categories":["JavaScript"],"tags":["ecmascript","javascript"],"template":"post"},"fields":{"slug":"/gueltigkeitsbereiche-von-variablen/","date":"2019-08-01T00:00:00.000Z"}}},"pageContext":{"slug":"/gueltigkeitsbereiche-von-variablen/"}}}